<!DOCTYPE html>
<html lang="zh-Hans">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Asciidoctor 0.1.4">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="基于JavaScript Promise进行异步编程的基本使用方法以及测试的编写方法、应用及反模式等内容的文档。">
<meta name="keywords" content="JavaScript, ECMAScript, Promise, 日语, 中文, 使用方法, 教程, 参考手册">
<title>JavaScript Promise迷你书（中文版）</title>
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }
audio, canvas, video { display: inline-block; }
audio:not([controls]) { display: none; height: 0; }
[hidden] { display: none; }
html { background: #fff; color: #000; font-family: sans-serif; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; }
body { margin: 0; }
a:focus { outline: thin dotted; }
a:active, a:hover { outline: 0; }
h1 { font-size: 2em; margin: 0.67em 0; }
abbr[title] { border-bottom: 1px dotted; }
b, strong { font-weight: bold; }
dfn { font-style: italic; }
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }
mark { background: #ff0; color: #000; }
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }
pre { white-space: pre-wrap; }
q { quotes: "\201C" "\201D" "\2018" "\2019"; }
small { font-size: 80%; }
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }
img { border: 0; }
svg:not(:root) { overflow: hidden; }
figure { margin: 0; }
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }
legend { border: 0; padding: 0; }
button, input, select, textarea { font-family: inherit; font-size: 100%; margin: 0; }
button, input { line-height: normal; }
button, select { text-transform: none; }
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; cursor: pointer; }
button[disabled], html input[disabled] { cursor: default; }
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; padding: 0; }
input[type="search"] { -webkit-appearance: textfield; -moz-box-sizing: content-box; -webkit-box-sizing: content-box; box-sizing: content-box; }
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }
textarea { overflow: auto; vertical-align: top; }
table { border-collapse: collapse; border-spacing: 0; }
*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }
html, body { font-size: 100%; }
body { background: white; color: #222222; padding: 0; margin: 0; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }
a:hover { cursor: pointer; }
a:focus { outline: none; }
img, object, embed { max-width: 100%; height: auto; }
object, embed { height: 100%; }
img { -ms-interpolation-mode: bicubic; }
#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }
.left { float: left !important; }
.right { float: right !important; }
.text-left { text-align: left !important; }
.text-right { text-align: right !important; }
.text-center { text-align: center !important; }
.text-justify { text-align: justify !important; }
.hide { display: none; }
.antialiased, body { -webkit-font-smoothing: antialiased; }
img { display: inline-block; vertical-align: middle; }
textarea { height: auto; min-height: 50px; }
select { width: 100%; }
p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }
.subheader, #content #toctitle, .admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .videoblock > .title, .listingblock > .title, .literalblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title, .tableblock > caption { line-height: 1.4; color: #7a2518; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }
a { color: #005498; text-decoration: underline; line-height: inherit; }
a:hover, a:focus { color: #00467f; }
a img { border: none; }
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: Georgia, "URW Bookman L", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; color: #ba3925; text-rendering: optimizeLegibility; margin-top: 1em; margin-bottom: 0.5em; line-height: 1.2125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #e99b8f; line-height: 0; }
h1 { font-size: 2.125em; }
h2 { font-size: 1.6875em; }
h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }
h4 { font-size: 1.125em; }
h5 { font-size: 1.125em; }
h6 { font-size: 1em; }
hr { border: solid #dddddd; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }
em, i { font-style: italic; line-height: inherit; }
strong, b { font-weight: bold; line-height: inherit; }
small { font-size: 60%; line-height: inherit; }
code { font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; color: #6d180b; }
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }
ul, ol { margin-left: 1.5em; }
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }
abbr, acronym { text-transform: uppercase; font-size: 90%; color: #222222; border-bottom: 1px dotted #dddddd; cursor: help; }
abbr { text-transform: none; }
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: inherit; color: #555555; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #555555; }
blockquote, blockquote p { line-height: 1.6; color: #6f6f6f; }
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }
.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }
@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
.print-only { display: none !important; }
@media print { * { background: transparent !important; color: #000 !important; box-shadow: none !important; text-shadow: none !important; }
  a, a:visited { text-decoration: underline; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; page-break-inside: avoid; }
  thead { display: table-header-group; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page { margin: 0.5cm; }
  p, h2, h3, #toctitle, .sidebarblock > .content > .title { orphans: 3; widows: 3; }
  h2, h3, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
  .hide-on-print { display: none !important; }
  .print-only { display: block !important; }
  .hide-for-print { display: none !important; }
  .show-for-print { display: inherit !important; } }
table { background: white; margin-bottom: 1.25em; border: solid 1px #dddddd; }
table thead, table tfoot { background: whitesmoke; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: #222222; text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: #222222; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f9f9f9; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.6; }
.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }
*:not(pre) > code { font-size: 0.9375em; padding: 1px 3px 0; white-space: nowrap; background-color: #f2f2f2; border: 1px solid #cccccc; -webkit-border-radius: 4px; border-radius: 4px; text-shadow: none; }
pre, pre > code { line-height: 1.4; color: inherit; font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; }
kbd.keyseq { color: #555555; }
kbd:not(.keyseq) { display: inline-block; color: #222222; font-size: 0.75em; line-height: 1.4; background-color: #F7F7F7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; margin: -0.15em 0.15em 0 0.15em; padding: 0.2em 0.6em 0.2em 0.5em; vertical-align: middle; white-space: nowrap; }
kbd kbd:first-child { margin-left: 0; }
kbd kbd:last-child { margin-right: 0; }
.menuseq, .menu { color: #090909; }
p a > code:hover { color: #561309; }
#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }
#header { margin-bottom: 2.5em; }
#header > h1 { color: black; font-weight: normal; border-bottom: 1px solid #dddddd; margin-bottom: -28px; padding-bottom: 32px; }
#header span { color: #6f6f6f; }
#header #revnumber { text-transform: capitalize; }
#header br { display: none; }
#header br + span { padding-left: 3px; }
#header br + span:before { content: "\2013 \0020"; }
#header br + span.author { padding-left: 0; }
#header br + span.author:before { content: ", "; }
#toc { border-bottom: 3px double #ebebeb; padding-bottom: 1.25em; }
#toc > ul { margin-left: 0.25em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
#toc ul { list-style-type: none; }
#toctitle { color: #7a2518; }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; }
  #toc.toc2 { position: fixed; width: 20em; left: 0; top: 0; border-right: 1px solid #ebebeb; border-bottom: 0; z-index: 1000; padding: 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; }
  #toc.toc2 > ul { font-size: .95em; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1.25em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; }
  body.toc2.toc-right #toc.toc2 { border-right: 0; border-left: 1px solid #ebebeb; left: auto; right: 0; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; border-width: 0; -webkit-border-radius: 4px; border-radius: 4px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }
#content #toc a { text-decoration: none; }
#content #toctitle { font-weight: bold; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-size: 1em; padding-left: 0.125em; }
#footer { max-width: 100%; background-color: #222222; padding: 1.25em; }
#footer-text { color: #dddddd; line-height: 1.44; }
.sect1 { padding-bottom: 1.25em; }
.sect1 + .sect1 { border-top: 3px double #ebebeb; }
#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; width: 1em; margin-left: -1em; display: block; text-decoration: none; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: '\00A7'; font-size: .85em; vertical-align: text-top; display: block; margin-top: 0.05em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #ba3925; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #a53221; }
.imageblock, .literalblock, .listingblock, .verseblock, .videoblock { margin-bottom: 1.25em; }
.admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .videoblock > .title, .listingblock > .title, .literalblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-align: left; font-weight: bold; }
.tableblock > caption { text-align: left; font-weight: bold; white-space: nowrap; overflow: visible; max-width: 0; }
table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }
.admonitionblock > table { border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #dddddd; color: #6f6f6f; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }
.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 4px; border-radius: 4px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6, .exampleblock > .content p { color: #333333; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6 { line-height: 1; margin-bottom: 0.625em; }
.exampleblock > .content h1.subheader, .exampleblock > .content h2.subheader, .exampleblock > .content h3.subheader, .exampleblock > .content .subheader#toctitle, .sidebarblock.exampleblock > .content > .subheader.title, .exampleblock > .content h4.subheader, .exampleblock > .content h5.subheader, .exampleblock > .content h6.subheader { line-height: 1.4; }
.exampleblock.result > .content { -webkit-box-shadow: 0 1px 8px #d9d9d9; box-shadow: 0 1px 8px #d9d9d9; }
.sidebarblock { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; -webkit-border-radius: 4px; border-radius: 4px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6, .sidebarblock p { color: #333333; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6 { line-height: 1; margin-bottom: 0.625em; }
.sidebarblock h1.subheader, .sidebarblock h2.subheader, .sidebarblock h3.subheader, .sidebarblock .subheader#toctitle, .sidebarblock > .content > .subheader.title, .sidebarblock h4.subheader, .sidebarblock h5.subheader, .sidebarblock h6.subheader { line-height: 1.4; }
.sidebarblock > .content > .title { color: #7a2518; margin-top: 0; line-height: 1.6; }
.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }
.literalblock > .content pre, .listingblock > .content pre { background: none; border-width: 1px 0; border-style: dotted; border-color: #bfbfbf; -webkit-border-radius: 4px; border-radius: 4px; padding: 0.75em 0.75em 0.5em 0.75em; word-wrap: break-word; }
.literalblock > .content pre.nowrap, .listingblock > .content pre.nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
.literalblock > .content pre > code, .listingblock > .content pre > code { display: block; }
@media only screen { .literalblock > .content pre, .listingblock > .content pre { font-size: 0.8em; } }
@media only screen and (min-width: 768px) { .literalblock > .content pre, .listingblock > .content pre { font-size: 0.9em; } }
@media only screen and (min-width: 1280px) { .literalblock > .content pre, .listingblock > .content pre { font-size: 1em; } }
.listingblock > .content { position: relative; }
.listingblock:hover code[class*=" language-"]:before { text-transform: uppercase; font-size: 0.9em; color: #999; position: absolute; top: 0.375em; right: 0.375em; }
.listingblock:hover code.asciidoc:before { content: "asciidoc"; }
.listingblock:hover code.clojure:before { content: "clojure"; }
.listingblock:hover code.css:before { content: "css"; }
.listingblock:hover code.groovy:before { content: "groovy"; }
.listingblock:hover code.html:before { content: "html"; }
.listingblock:hover code.java:before { content: "java"; }
.listingblock:hover code.javascript:before { content: "javascript"; }
.listingblock:hover code.python:before { content: "python"; }
.listingblock:hover code.ruby:before { content: "ruby"; }
.listingblock:hover code.scss:before { content: "scss"; }
.listingblock:hover code.xml:before { content: "xml"; }
.listingblock:hover code.yaml:before { content: "yaml"; }
.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }
.listingblock.terminal pre .command:not([data-prompt]):before { content: '$'; }
table.pyhltable { border: 0; margin-bottom: 0; }
table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; }
table.pyhltable td.code { padding-left: .75em; padding-right: 0; }
.highlight.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #dddddd; }
.highlight.pygments .lineno { display: inline-block; margin-right: .25em; }
table.pyhltable .linenodiv { background-color: transparent !important; padding-right: 0 !important; }
.quoteblock { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
.quoteblock blockquote { margin: 0 0 1.25em 0; padding: 0 0 0.5625em 0; border: 0; }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: -.25em; padding-bottom: 0.5625em; font-size: inherit; color: #555555; }
.quoteblock .attribution br { display: none; }
.quoteblock .attribution cite { display: block; margin-bottom: 0.625em; }
table thead th, table tfoot th { font-weight: bold; }
table.tableblock.grid-all { border-collapse: separate; border-spacing: 1px; -webkit-border-radius: 4px; border-radius: 4px; border-top: 1px solid #dddddd; border-bottom: 1px solid #dddddd; }
table.tableblock.frame-topbot, table.tableblock.frame-none { border-left: 0; border-right: 0; }
table.tableblock.frame-sides, table.tableblock.frame-none { border-top: 0; border-bottom: 0; }
table.tableblock td .paragraph:last-child p, table.tableblock td > p:last-child { margin-bottom: 0; }
th.tableblock.halign-left, td.tableblock.halign-left { text-align: left; }
th.tableblock.halign-right, td.tableblock.halign-right { text-align: right; }
th.tableblock.halign-center, td.tableblock.halign-center { text-align: center; }
th.tableblock.valign-top, td.tableblock.valign-top { vertical-align: top; }
th.tableblock.valign-bottom, td.tableblock.valign-bottom { vertical-align: bottom; }
th.tableblock.valign-middle, td.tableblock.valign-middle { vertical-align: middle; }
p.tableblock.header { color: #222222; font-weight: bold; }
td > div.verse { white-space: pre; }
ol { margin-left: 1.75em; }
ul li ol { margin-left: 1.5em; }
dl dd { margin-left: 1.125em; }
dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }
ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }
ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }
ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }
ul.checklist li > p:first-child > i[class^="icon-check"]:first-child, ul.checklist li > p:first-child > input[type="checkbox"]:first-child { margin-right: 0.25em; }
ul.checklist li > p:first-child > input[type="checkbox"]:first-child { position: relative; top: 1px; }
ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }
.unstyled dl dt { font-weight: normal; font-style: normal; }
ol.arabic { list-style-type: decimal; }
ol.decimal { list-style-type: decimal-leading-zero; }
ol.loweralpha { list-style-type: lower-alpha; }
ol.upperalpha { list-style-type: upper-alpha; }
ol.lowerroman { list-style-type: lower-roman; }
ol.upperroman { list-style-type: upper-roman; }
ol.lowergreek { list-style-type: lower-greek; }
.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }
td.hdlist1 { padding-right: .8em; font-weight: bold; }
td.hdlist1, td.hdlist2 { vertical-align: top; }
.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }
.colist > table tr > td:first-of-type { padding: 0 .8em; line-height: 1; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }
.qanda > ol > li > p > em:only-child { color: #00467f; }
.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }
.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }
.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }
a.image { text-decoration: none; }
span.footnote, span.footnoteref { vertical-align: super; font-size: 0.875em; }
span.footnote a, span.footnoteref a { text-decoration: none; }
#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -.25em 0 .75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em; line-height: 1.3; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.2em; margin-bottom: .2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }
.gist .file-data > table { border: none; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }
div.unbreakable { page-break-inside: avoid; }
.big { font-size: larger; }
.small { font-size: smaller; }
.underline { text-decoration: underline; }
.overline { text-decoration: overline; }
.line-through { text-decoration: line-through; }
.aqua { color: #00bfbf; }
.aqua-background { background-color: #00fafa; }
.black { color: black; }
.black-background { background-color: black; }
.blue { color: #0000bf; }
.blue-background { background-color: #0000fa; }
.fuchsia { color: #bf00bf; }
.fuchsia-background { background-color: #fa00fa; }
.gray { color: #606060; }
.gray-background { background-color: #7d7d7d; }
.green { color: #006000; }
.green-background { background-color: #007d00; }
.lime { color: #00bf00; }
.lime-background { background-color: #00fa00; }
.maroon { color: #600000; }
.maroon-background { background-color: #7d0000; }
.navy { color: #000060; }
.navy-background { background-color: #00007d; }
.olive { color: #606000; }
.olive-background { background-color: #7d7d00; }
.purple { color: #600060; }
.purple-background { background-color: #7d007d; }
.red { color: #bf0000; }
.red-background { background-color: #fa0000; }
.silver { color: #909090; }
.silver-background { background-color: #bcbcbc; }
.teal { color: #006060; }
.teal-background { background-color: #007d7d; }
.white { color: #bfbfbf; }
.white-background { background-color: #fafafa; }
.yellow { color: #bfbf00; }
.yellow-background { background-color: #fafa00; }
span.icon > [class^="icon-"], span.icon > [class*=" icon-"] { cursor: default; }
.admonitionblock td.icon [class^="icon-"]:before { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #005498; color: #003f72; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }
.conum { display: inline-block; color: white !important; background-color: #222222; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; width: 20px; height: 20px; font-size: 12px; font-weight: bold; line-height: 20px; font-family: Arial, sans-serif; font-style: normal; position: relative; top: -2px; letter-spacing: -1px; }
.conum * { color: white !important; }
.conum + b { display: none; }
.conum:after { content: attr(data-value); }
.conum:not([data-value]):empty { display: none; }
.literalblock > .content > pre, .listingblock > .content > pre { -webkit-border-radius: 0; border-radius: 0; }

</style>
<link rel="stylesheet" href="public/css/font-awesome.min.css">
<style>
/* Foundation stylesheet for CodeRay (to match GitHub theme) | MIT License | http://foundation.zurb.com */
table.CodeRay { border-collapse: collapse; padding: 2px; margin-bottom: 0; border: 0; background: transparent; }
table.CodeRay td { padding: 0 .5em; vertical-align: top; }
table.CodeRay td.line-numbers { text-align: right; color: #999; border-right: 1px solid #e5e5e5; padding-left: 0; }
span.line-numbers { border-right: 1px solid #E5E5E5; color: #999; display: inline-block; margin-right: 0.5em; padding-right: 0.5em; }
.CodeRay td.line-numbers strong, .CodeRay span.line-numbers strong { font-weight: normal; }
.CodeRay .debug { color: white !important; background: blue !important; }
.CodeRay .annotation { color: #007; }
.CodeRay .attribute-name { color: #f08; }
.CodeRay .attribute-value { color: #700; }
.CodeRay .binary { color: #509; }
.CodeRay .comment  { color: #999; font-style: italic; }
.CodeRay .char { color: #04D; }
.CodeRay .char .content { color: #04D; }
.CodeRay .char .delimiter { color: #039; }
.CodeRay .class { color: #458; }
.CodeRay .complex { color: #A08; }
.CodeRay .constant { color: teal; }
.CodeRay .color { color: #0A0; }
.CodeRay .class-variable { color: #369; }
.CodeRay .decorator { color: #B0B; }
.CodeRay .definition { color: #099; }
.CodeRay .directive { color: #088; }
.CodeRay .delimiter { color: black; }
.CodeRay .doc { color: #970; }
.CodeRay .doctype { color: #34b; }
.CodeRay .doc-string { color: #D42; }
.CodeRay .escape  { color: #666; }
.CodeRay .entity { color: #800; }
.CodeRay .error { color: #808; }
.CodeRay .exception { color: #C00; }
.CodeRay .filename { color: #099; }
.CodeRay .function { color: #900; }
.CodeRay .global-variable { color: teal; }
.CodeRay .hex { color: #058; }
.CodeRay .integer  { color: #099; }
.CodeRay .include { color: #B44; }
.CodeRay .inline { color: black; }
.CodeRay .inline .inline { background: #ccc; }
.CodeRay .inline .inline .inline { background: #bbb; }
.CodeRay .inline .inline-delimiter { color: #D14; }
.CodeRay .inline-delimiter { color: #D14; }
.CodeRay .important { color: #f00; }
.CodeRay .interpreted { color: #B2B; }
.CodeRay .instance-variable { color: teal; }
.CodeRay .label { color: #970; }
.CodeRay .local-variable { color: #963; }
.CodeRay .octal { color: #40E; }
.CodeRay .predefined { color: #369; }
.CodeRay .preprocessor { color: #579; }
.CodeRay .pseudo-class { color: #00C; }
.CodeRay .predefined-type { color: #074; }
.CodeRay .reserved, .keyword  { color: #000; }
.CodeRay .key { color: #808; }
.CodeRay .key .delimiter { color: #606; }
.CodeRay .key .char { color: #80f; }
.CodeRay .value { color: #088; }
.CodeRay .regexp { background-color: #fff0ff; }
.CodeRay .regexp .content { color: #808; }
.CodeRay .regexp .delimiter { color: #404; }
.CodeRay .regexp .modifier { color: #C2C; }
.CodeRay .regexp .function  { color: #404; font-weight: bold; }
.CodeRay .string { color: #D20; }
.CodeRay .string .string { }
.CodeRay .string .string .string { background-color: #ffd0d0; }
.CodeRay .string .content { color: #D14; }
.CodeRay .string .char { color: #D14; }
.CodeRay .string .delimiter { color: #D14; }
.CodeRay .shell { color: #D14; }
.CodeRay .shell .content { }
.CodeRay .shell .delimiter { color: #D14; }
.CodeRay .symbol { color: #990073; }
.CodeRay .symbol .content { color: #A60; }
.CodeRay .symbol .delimiter { color: #630; }
.CodeRay .tag, .CodeRay .attribute-name { color: #070; }
.CodeRay .tag-special { color: #D70; }
.CodeRay .type { color: #339; }
.CodeRay .variable  { color: #036; }
.CodeRay .insert { background: #afa; }
.CodeRay .delete { background: #faa; }
.CodeRay .change { color: #aaf; background: #007; }
.CodeRay .head { color: #f8f; background: #505; }
.CodeRay .insert .insert { color: #080; }
.CodeRay .delete .delete { color: #800; }
.CodeRay .change .change { color: #66f; }
.CodeRay .head .head { color: #f4f; }

</style>
<meta name="google-site-verification" content="bMotEbgYwkzA3k4PkuyK_NUdz0bKh-Phz0oUwNmRSVo" />
<script type="text/javascript" src="public/js/google-analytics.js" async></script>
<link rel="canonical" href="http://azu.github.io/promises-book/">
<link rel="alternate" type="application/atom+xml" title="JavaScript Promiseの本" href="https://github.com/azu/promises-book/releases.atom">
<link href="public/img/favicon.ico" rel="shortcut icon" type="image/x-icon">
<link rel="icon" sizes="16x16 32x32" href="public/img/favicon.ico">
<link rel="stylesheet" type="text/css" href="public/css/overload.css"/>
<link rel="stylesheet" type="text/css" href="public/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" href="public/css/mirror-console-compoenent.css">
<script type="text/javascript" src="public/js/build/app.js" async defer></script>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>JavaScript Promise迷你书（中文版）</h1>
<span id="author" class="author">原著：azu / 翻译：liubin、kaku、honnkyou</span><br>
<span id="revnumber">version 1.4.1</span>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#introduction">前言</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_">写作初衷</a></li>
<li><a href="#__2">开始阅读之前</a></li>
<li><a href="#__3">格式约定</a></li>
<li><a href="#__4">推荐浏览器</a></li>
<li><a href="#__5">运行示例代码</a></li>
<li><a href="#__license">本书源代码/License</a></li>
<li><a href="#__6">意见和疑问</a></li>
</ul>
</li>
<li><a href="#chapter1-what-is-promise">1. Chapter.1 - 什么是Promise</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#what-is-promise">1.1. 什么是Promise</a></li>
<li><a href="#promises-overview">1.2. Promise简介</a></li>
<li><a href="#how-to-write-promise">1.3. 编写Promise代码</a></li>
</ul>
</li>
<li><a href="#chapter2-how-to-write-promise">2. Chapter.2 - 实战Promise</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#ch2-promise-resolve">2.1. Promise.resolve</a></li>
<li><a href="#ch2-promise-reject">2.2. Promise.reject</a></li>
<li><a href="#promise-is-always-async">2.3. 专栏: Promise只能进行异步操作？</a></li>
<li><a href="#ch2-promise.then">2.4. Promise#then</a></li>
<li><a href="#ch2-promise-catch">2.5. Promise#catch</a></li>
<li><a href="#then-return-new-promise">2.6. 专栏: 每次调用then都会返回一个新创建的promise对象</a></li>
<li><a href="#ch2-promise-and-array">2.7. Promise和数组</a></li>
<li><a href="#ch2-promise-all">2.8. Promise.all</a></li>
<li><a href="#ch2-promise-race">2.9. Promise.race</a></li>
<li><a href="#then-or-catch">2.10. then or catch?</a></li>
</ul>
</li>
<li><a href="#chapter3-promise-testing">3. Chapter.3 - Promise测试</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#basic-tests">3.1. 基本测试</a></li>
<li><a href="#mocha-promise">3.2. Mocha对Promise的支持</a></li>
<li><a href="#controllable-tests">3.3. 编写可控测试（controllable tests）</a></li>
</ul>
</li>
<li><a href="#chapter4-advanced-promise">4. Chapter.4 - Advanced</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#promise-library">4.1. Promise的实现类库（Library）</a></li>
<li><a href="#resolve-thenable">4.2. Promise.resolve和Thenable</a></li>
<li><a href="#not-throw-use-reject">4.3. 使用reject而不是throw</a></li>
<li><a href="#deferred-and-promise">4.4. Deferred和Promise</a></li>
<li><a href="#race-delay-timeout">4.5. 使用Promise.race和delay取消XHR请求</a></li>
<li><a href="#promise-done">4.6. 什么是 Promise.prototype.done ？</a></li>
<li><a href="#promise-and-method-chain">4.7. Promise和方法链（method chain）</a></li>
<li><a href="#promise-sequence">4.8. 使用Promise进行顺序（sequence）处理</a></li>
</ul>
</li>
<li><a href="#promise-api-reference">5. Promises API Reference</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#promise.then">5.1. Promise#then</a></li>
<li><a href="#promise.catch">5.2. Promise#catch</a></li>
<li><a href="#Promise.resolve">5.3. Promise.resolve</a></li>
<li><a href="#Promise.reject">5.4. Promise.reject</a></li>
<li><a href="#Promise.all">5.5. Promise.all</a></li>
<li><a href="#Promise.race">5.6. Promise.race</a></li>
</ul>
</li>
<li><a href="#promise-glossary">6. 用語集</a></li>
<li><a href="#resouce-link">7. 参考网站</a></li>
<li><a href="#about-author">8. 关于作者</a></li>
<li><a href="#about-translators">9. 关于译者</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#omake-message">9.1. 给原著者留言、后记</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="github-ribbon">
<a href="https://github.com/liubin/promises-book/"><img style="border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" /></a>
</div>
<div class="paragraph">
<p><span class="icon"><a class="image" href="https://twitter.com/search?q=%23Promise%E6%9C%AC"><i class="icon-twitter icon-2x"></i></a></span> Hash tag <a href="https://twitter.com/search?q=%23Promise%E8%BF%B7%E4%BD%A0%E4%B9%A6">#Promise迷你书</a></p>
</div>
<div class="paragraph">
<p><span class="icon"><a class="image" href="https://github.com/azu/promises-book/releases.atom"><i class="icon-rss icon-2x"></i></a></span> 可以从这里 <a href="https://github.com/azu/promises-book/releases.atom">RSS</a> 得到更新信息</p>
</div>
<div class="social-button-wrapper">
<iframe src="http://ghbtns.com/github-btn.html?user=azu&repo=promises-book&type=watch&count=true"
  allowtransparency="true" frameborder="0" scrolling="0" width="100" height="20"></iframe>

<a href="https://twitter.com/share" class="twitter-share-button" data-url="http://azu.github.io/promises-book/" data-lang="ja" data-hashtags="Promise本">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

</div>
<div class="paragraph">
<p>本书以Creative Commons Attribution-NonCommercial <a href="https://github.com/azu/promises-book/#license">许可证</a>发布。
另外你也可以从下面的链接下载PDF版本。</p>
</div>
<div class="download-area">
<a class="download-button pdf" id="download-pdf" href="http://liubin.github.io/promises-book/javascript-promise-book.pdf" download="javascript-promise-book.pdf">下载本书PDF版本</a>
<a class="download-button source-code" href="https://github.com/liubin/promises-book/">下载本书源代码</a>
</div>
<div class="paragraph">
<p>关于本电子书的创作过程有兴趣的读者，可以下载这个文档供参考（日文版） <a href="https://gumroad.com/l/javascript-promise">制作过程</a>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="image"><a class="image" href="https://gumroad.com/l/javascript-promise"><img src="./public/img/gumroad-green.svg" alt="（日文版）附录下载"></a></span> <a href="https://gumroad.com/l/javascript-promise">（日文版）附录下载</a></p>
</li>
<li>
<p>本书开始编写的原因，如何编写的，以及编写过程是如何运作的。</p>
</li>
<li>
<p>可以在Gumroad上以包括0元在内的任何价格购买本附录内容。</p>
</li>
<li>
<p>如果你想捐赠，也可以通过本附录链接以任意的价格购买本附录的方式进行。</p>
</li>
</ul>
</div>
<hr>
<div style="page-break-after: always;"></div>
</div>
</div>
<div class="sect1">
<h2 id="introduction">前言</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_">写作初衷</h3>
<div class="paragraph">
<p>本书的目的是以目前还在制定中的<a href="#es6-promises">ECMAScript 6 Promises</a>规范为中心，着重向各位读者介绍JavaScript中对Promise相关技术的支持情况。</p>
</div>
<div class="paragraph">
<p>通过阅读本书，我们希望各位读者能在下面三个目标上有所收获。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>学习Promise相关内容，能熟练使用Promise模式并进行测试</p>
</li>
<li>
<p>学习Promise适合什么、不适合什么，知道Promise不是万能的，不能什么都想用Promise来解决</p>
</li>
<li>
<p>以ES6 Promises为基础进行学习，逐渐发展形成自己的风格</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>像上面所提到的那样，本书主要是以<a href="#es6-promises">ES6 Promises</a>，即JavaScript的标准规范为基础的、Promise的相关知识为主要讲解内容。</p>
</div>
<div class="paragraph">
<p>在Firefox和Chrome这样技术比较超前的浏览器上，不需要安装额外的插件就能使用Promise功能，此外ES6 Promises的规范来源于<a href="#promises-aplus">Promises/A+</a>社区，它有很多版本的实现。</p>
</div>
<div class="paragraph">
<p>我们将会从基础API开始介绍可以在浏览器的原生支持或者通过插件支持的Promise功能。
也希望各位读者能了解这其中Promise适合干什么，不适合干什么，能根据实际需求选择合适的技术实现方案。</p>
</div>
</div>
<div class="sect2">
<h3 id="__2">开始阅读之前</h3>
<div class="paragraph">
<p>本书的阅读对象需要对JavaScript有基本的了解和知识。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://shop.oreilly.com/product/9780596517748.do">JavaScript: The Good Parts</a></p>
</li>
<li>
<p><a href="http://shop.oreilly.com/product/9780596806767.do">JavaScript Patterns</a></p>
</li>
<li>
<p><a href="http://shop.oreilly.com/product/9780596805531.do">JavaScript: The Definitive Guide, 6th Edition</a></p>
</li>
<li>
<p><a href="http://gihyo.jp/book/2011/978-4-7741-4813-7?ard=1400715177">Perfect JavaScript（日文版）</a></p>
</li>
<li>
<p><a href="http://books.shoeisha.co.jp/book/b107881.html">Effective JavaScript（日文版）</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果你读过上面的其中一本的话，就应该非常容易理解本书的内容了。</p>
</div>
<div class="paragraph">
<p>另外如果你有使用JavaScript编写Web应用程序的经验，或者使用Node.js编写过命令行、服务器端程序的话，那么你可能会对本文中的一些内容感到非常熟悉。</p>
</div>
<div class="paragraph">
<p>本书的一本分章节将会以Node.js环境为背景进行说明，如果你有Node.js基础的话，那么一定会非常容易理解这部分内容了。</p>
</div>
</div>
<div class="sect2">
<h3 id="__3">格式约定</h3>
<div class="paragraph">
<p>本书为了节约篇幅，用了下面一些格式上的约定。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>关于Promise的术语请参考<a href="#promise-glossary">术语集</a>。</p>
<div class="ulist">
<ul>
<li>
<p>一般一个名词第一次出现时都会附带相关链接。</p>
</li>
</ul>
</div>
</li>
<li>
<p>实例方法都用 instance#method 的形式。</p>
<div class="ulist">
<ul>
<li>
<p>比如 <code>Promise#then</code> 这种写法表示的是 Promise的实例对象的 <code>then</code> 这一方法。</p>
</li>
</ul>
</div>
</li>
<li>
<p>对象方法都采用 object.method 的形式。</p>
<div class="ulist">
<ul>
<li>
<p>这沿用了JavaScript中的使用方式，<code>Promise.all</code> 表示的是一个静态方法。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
这部分内容主要讲述的是对正文部分的补充说明。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="__4">推荐浏览器</h3>
<div class="paragraph">
<p>我们推荐使用内置对Promise支持的浏览器来阅读本书。</p>
</div>
<div class="paragraph">
<p>Firefox和Chrome的话都支持<a href="#es6-promises">ES6 Promises</a>标准。</p>
</div>
<div class="paragraph">
<p>此外，虽然不是推荐的阅读环境，但是读者还是能在iOS等移动终端上阅读本书。</p>
</div>
<div class="iframe-wrapper" style="width: 100%; height: 350px; overflow: auto; -webkit-overflow-scrolling: touch;">
<iframe src="http://caniuse.com/promises/embed/agents=desktop" width="100%" height="350px"></iframe>
</div>
</div>
<div class="sect2">
<h3 id="__5">运行示例代码</h3>
<div class="paragraph">
<p>本网站使用了Promise的<a href="#promise-polyfill">Polyfill类库</a>，因此即使在不支持Promise的浏览器上也能执行示例代码。</p>
</div>
<div class="paragraph">
<p>此外像下面这样，各位读者可以通过运行按钮来运行可执行的示例代码。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve){
    resolve(<span class="integer">42</span>);
});
promise.then(<span class="keyword">function</span>(value){
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="tutorial-area">
按下 <button class="mirror-console-button mirror-console-run">运行</button> 按钮之后，代码区会变成编辑区，代码也会被执行。当然你也可以通过这个按钮再次运行代码。<br />
<button class="mirror-console-button mirror-console-clear">清除log</button> 按钮用于清除由 <code>console.log</code> 打印出来的log。
<br />
<button class="mirror-console-button mirror-console-exit">退出</button>按钮用来退出编辑模式。
</div>
<div class="paragraph">
<p>如果你对哪里有疑问的话，都可以现场修改代码并执行，以加深对该部分代码的理解。</p>
</div>
</div>
<div class="sect2">
<h3 id="__license">本书源代码/License</h3>
<div class="paragraph">
<p>本书中示例代码都可以在GitHub上找到。</p>
</div>
<div class="paragraph">
<p>本书采用 <a href="http://asciidoctor.org/">AsciiDoc</a> 格式编写。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/azu/promises-book">azu/promises-book</a> <span class="image"><a class="image" href="https://travis-ci.org/azu/promises-book"><img src="https://travis-ci.org/azu/promises-book.svg?branch=master" alt="Build Status"></a></span></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外代码仓库中还包含本书示例代码的测试代码。</p>
</div>
<div class="paragraph">
<p>源代码的许可证为MIT许可证，文章内容可以基于CC-BY-NC使用。</p>
</div>
</div>
<div class="sect2">
<h3 id="__6">意见和疑问</h3>
<div class="paragraph">
<p>如果有意见或者问题的话，可以直接在GitHub上提Issue即可。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/azu/promises-book/issues?state=open">Issues · azu/promises-book 日文版</a></p>
</li>
<li>
<p><a href="https://github.com/liubin/promises-book/issues?state=open">Issues · liubin/promises-book 中文版</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外，你也可以在 <a href="https://gitter.im/azu/promises-book">在线聊天</a> 上留言。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="image"><a class="image" href="https://gitter.im/azu/promises-book"><img src="https://badges.gitter.im/azu/promises-book.png" alt="Gitter"></a></span></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>各位读者除了能免费阅读本书，也有编辑本书的权利。你可以在GitHub上通过 <a href="https://github.com/azu/promises-book/pulls">Pull Requests</a> 来贡献自己的工作。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter1-what-is-promise">1. Chapter.1 - 什么是Promise</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章将主要对JavaScript中的Promise进行入门级的介绍。</p>
</div>
<div class="sect2">
<h3 id="what-is-promise">1.1. 什么是Promise</h3>
<div class="paragraph">
<p>首先让我们来了解一下到底什么是Promise。</p>
</div>
<div class="paragraph">
<p>Promise是抽象异步处理对象以及对其进行各种操作的组件。
其详细内容在接下来我们还会进行介绍，Promise并不是从JavaScript中发祥的概念。</p>
</div>
<div class="paragraph">
<p>Promise最初被提出是在 <a href="http://erights.org/elib/distrib/pipeline.html">E语言</a>中，
它是基于并列/并行处理设计的一种编程语言。</p>
</div>
<div class="paragraph">
<p>现在JavaScript也拥有了这种特性，这就是本书所介绍的JavaScript Promise。</p>
</div>
<div class="paragraph">
<p>另外，如果说到基于JavaScript的异步处理，我想大多数都会想到利用回调函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="error">使</span><span class="error">用</span><span class="error">了</span><span class="error">回</span><span class="error">调</span><span class="error">函</span><span class="error">数</span><span class="error">的</span><span class="error">异</span><span class="error">步</span><span class="error">处</span><span class="error">理</span>
----
getAsync(<span class="string"><span class="delimiter">&quot;</span><span class="content">fileA.txt</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span>(error, result){<i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">if</span>(error){<span class="comment">// 取得失败时的处理</span>
        <span class="keyword">throw</span> error;
    }
    <span class="comment">// 取得成功时的处理</span>
});
----
&lt;<span class="integer">1</span>&gt; <span class="error">传</span><span class="error">给</span><span class="error">回</span><span class="error">调</span><span class="error">函</span><span class="error">数</span><span class="error">的</span><span class="error">参</span><span class="error">数</span><span class="error">为</span>(error<span class="error">对</span><span class="error">象</span><span class="error">，</span> <span class="error">执</span><span class="error">行</span><span class="error">结</span><span class="error">果</span>)<span class="error">组</span><span class="error">合</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Node.js等则规定在JavaScript的回调函数的第一个参数为 <code>Error</code> 对象，这也是它的一个惯例。</p>
</div>
<div class="paragraph">
<p>像上面这样基于回调函数的异步处理如果统一参数使用规则的话，写法也会很明了。
但是，这也仅是编码规约而已，即使采用不同的写法也不会出错。</p>
</div>
<div class="paragraph">
<p>而Promise则是把类似的异步处理对象和处理规则进行规范化，
并按照采用统一的接口来编写，而采取规定方法之外的写法都会出错。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="error">下</span><span class="error">面</span><span class="error">是</span><span class="error">使</span><span class="error">用</span><span class="error">了</span>Promise<span class="error">进</span><span class="error">行</span><span class="error">异</span><span class="error">步</span><span class="error">处</span><span class="error">理</span><span class="error">的</span><span class="error">一</span><span class="error">个</span><span class="error">例</span><span class="error">子</span>
----
<span class="keyword">var</span> promise = getAsyncPromise(<span class="string"><span class="delimiter">&quot;</span><span class="content">fileA.txt</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="1"></i><b>(1)</b>
promise.then(<span class="keyword">function</span>(result){
    <span class="comment">// 获取文件内容成功时的处理</span>
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    <span class="comment">// 获取文件内容失败时的处理</span>
});
----
&lt;<span class="integer">1</span>&gt; <span class="error">返</span><span class="error">回</span>promise<span class="error">对</span><span class="error">象</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以向这个预设了抽象化异步处理的promise对象，
注册这个promise对象执行成功时和失败时相应的回调函数。</p>
</div>
<div class="paragraph">
<p>这和回调函数方式相比有哪些不同之处呢？
在使用promise进行一步处理的时候，我们必须按照接口规定的方法编写处理代码。</p>
</div>
<div class="paragraph">
<p>也就是说，除promise对象规定的方法(这里的 <code>then</code> 或 <code>catch</code>)以外的方法都是不可以使用的，
而不会像回调函数方式那样可以自己自由的定义回调函数的参数，而必须严格遵守固定、统一的编程方式来编写代码。</p>
</div>
<div class="paragraph">
<p>这样，基于Promise的统一接口的做法，
就可以形成基于接口的各种各样的异步处理模式。</p>
</div>
<div class="paragraph">
<p>所以，promise的功能是可以将复杂的异步处理轻松地进行模式化，
这也可以说得上是使用promise的理由之一。</p>
</div>
<div class="paragraph">
<p>接下来，让我们在实践中来学习JavaScript的Promise吧。</p>
</div>
</div>
<div class="sect2">
<h3 id="promises-overview">1.2. Promise简介</h3>
<div class="paragraph">
<p>在 <a href="#es6-promises">ES6 Promises</a> 标准中定义的API还不是很多。</p>
</div>
<div class="paragraph">
<p>目前大致有下面三种类型。</p>
</div>
<div class="paragraph">
<p><strong>Constructor</strong></p>
</div>
<div class="paragraph">
<p>Promise类似于 <code>XMLHttpRequest</code>，从构造函数 <code>Promise</code> 来创建一个新建新<code>promise</code>对象作为接口。</p>
</div>
<div class="paragraph">
<p>要想创建一个promise对象、可以使用<code>new</code>来调用<code>Promise</code>的构造器来进行实例化。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve, reject) {
    <span class="comment">// 异步处理</span>
    <span class="comment">// 处理结束后、调用resolve 或 reject</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Instance Method</strong></p>
</div>
<div class="paragraph">
<p>对通过new生成的promise对象为了设置其值在 <strong>resolve</strong>(成功) / <strong>reject</strong>(失败)时调用的回调函数
可以使用<code>promise.then()</code> 实例方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">promise.then(onFulfilled, onRejected)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">resolve(成功)时</dt>
<dd>
<p><code>onFulfilled</code> 会被调用</p>
</dd>
<dt class="hdlist1">reject(失败)时</dt>
<dd>
<p><code>onRejected</code>  会被调用</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>onFulfilled</code>、<code>onRejected</code> 两个都为可选参数。</p>
</div>
<div class="paragraph">
<p><code>promise.then</code> 成功和失败时都可以使用。
另外在只想对异常进行处理时可以采用 <code>promise.then(undefined, onRejected)</code> 这种方式，只指定reject时的回调函数即可。
不过这种情况下 <code>promise.catch(onRejected)</code> 应该是个更好的选择。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">promise.<span class="keyword">catch</span>(onRejected)</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Static Method</strong></p>
</div>
<div class="paragraph">
<p>像 <code>Promise</code> 这样的全局对象还拥有一些静态方法。</p>
</div>
<div class="paragraph">
<p>包括 <code>Promise.all()</code> 还有 <code>Promise.resolve()</code> 等在内，主要都是一些对Promise进行操作的辅助方法。</p>
</div>
<div class="sect3">
<h4 id="_promise_workflow">1.2.1. Promise workflow</h4>
<div class="paragraph">
<p>我们先来看一看下面的示例代码。</p>
</div>
<div id="promise-workflow.js" class="listingblock executable">
<div class="title">promise-workflow.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">asyncFunction</span>() {
    <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        setTimeout(<span class="keyword">function</span> () {
            resolve(<span class="string"><span class="delimiter">'</span><span class="content">Async Hello world</span><span class="delimiter">'</span></span>);
        }, <span class="integer">16</span>);
    });
}
<i class="conum" data-value="2"></i><b>(2)</b>
asyncFunction().then(<span class="keyword">function</span> (value) {
    console.log(value);    <span class="comment">// =&gt; 'Async Hello world'</span>
}).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    console.log(error);
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>new</code> Promise构造器之后，会返回一个promise对象</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>&lt;1&gt;为promise对象用设置 <code>.then</code> 调用返回值时的回调函数。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>asyncFunction</code> 这个函数会返回promise对象，
对于这个promise对象，我们调用它的 <code>then</code> 方法来设置resolve后的回调函数，
<code>catch</code> 方法来设置发生错误时的回调函数。</p>
</div>
<div class="paragraph">
<p>该promise对象会在setTimeout之后的16ms时被resolve,
这时 <code>then</code> 的回调函数会被调用，并输出 <code>'Async Hello world'</code> 。</p>
</div>
<div class="paragraph">
<p>在这种情况下 <code>catch</code> 的回调函数并不会被执行（因为promise返回了resolve），
不过如果运行环境没有提供 <code>setTimeout</code> 函数的话，那么上面代码在执行中就会产生异常，在 <code>catch</code> 中设置的回调函数就会被执行。</p>
</div>
<div class="paragraph">
<p>当然，像<code>promise.then(onFulfilled, onRejected)</code> 的方法声明一样，
如果不使用<code>catch</code> 方法只使用 <code>then</code>方法的话，如下所示的代码也能完成相同的工作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">asyncFunction().then(<span class="keyword">function</span> (value) {
    console.log(value);
}, <span class="keyword">function</span> (error) {
    console.log(error);
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="promise-states">1.2.2. Promise的状态</h4>
<div class="paragraph">
<p>我们已经大概了解了Promise的处理流程，接下来让我们来稍微整理一下Promise的状态。</p>
</div>
<div class="paragraph">
<p>用<code>new Promise</code> 实例化的promise对象有以下三个状态。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">"has-resolution" - Fulfilled</dt>
<dd>
<p>resolve(成功)时。此时会调用 <code>onFulfilled</code></p>
</dd>
<dt class="hdlist1">"has-rejection"  - Rejected</dt>
<dd>
<p>reject(失败)时。此时会调用 <code>onRejected</code></p>
</dd>
<dt class="hdlist1">"unresolved" - Pending</dt>
<dd>
<p>既不是resolve也不是reject的状态。也就是promise对象刚被创建后的初始化状态等</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>关于上面这三种状态的读法，其中
左侧为在 <a href="#es6-promises">ES6 Promises</a> 规范中定义的术语，
而右侧则是在 <a href="#promises-aplus">Promises/A+</a> 中描述状态的术语。</p>
</div>
<div class="paragraph">
<p>基本上状态在代码中是不会涉及到的，所以名称也无需太在意。
在这本书中，我们会基于 <a href="http://promises-aplus.github.io/promises-spec/">Promises/A+</a> 中 <em>Pending</em> 、 <em>Fulfilled</em> 、 <em>Rejected</em> 的状态名称进行讲述。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch1_WhatsPromises/img/promise-states.png" alt="promise-states">
</div>
<div class="title">Figure 1. promise states</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 <a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects">ECMAScript Language Specification ECMA-262 6th Edition – DRAFT</a> 中 <code>[[PromiseStatus]]</code> 都是在内部定义的状态。
由于没有公开的访问 <code>[[PromiseStatus]]</code> 的用户API，所以暂时还没有查询其内部状态的方法。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>到此在本文中我们已经介绍了promise所有的三种状态。</p>
</div>
<div class="paragraph">
<p>promise对象的状态，从<em>Pending</em>转换为<em>Fulfilled</em>或<em>Rejected</em>之后，
这个promise对象的状态就不会再发生任何变化。</p>
</div>
<div class="paragraph">
<p>也就是说，Promise与Event等不同，在<code>.then</code> 后执行的函数可以肯定地说只会被调用一次。</p>
</div>
<div class="paragraph">
<p>另外，<em>Fulfilled</em>和<em>Rejected</em>这两个中的任一状态都可以表示为<strong>Settled</strong>(不变的)。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Settled</dt>
<dd>
<p>resolve(成功) 或 reject(失败)。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>从<em>Pending</em>和<em>Settled</em>的对称关系来看，Promise状态的种类/迁移是非常简单易懂的。</p>
</div>
<div class="paragraph">
<p>当promise的对象状态发生变化时，用<code>.then</code> 来定义只会被调用一次的函数。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://speakerdeck.com/kerrick/javascript-promises-thinking-sync-in-an-async-world">JavaScript Promises - Thinking Sync in an Async World // Speaker Deck</a>
这个ppt中有关于Promise状态迁移的非常容易理解的说明。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="how-to-write-promise">1.3. 编写Promise代码</h3>
<div class="paragraph">
<p>这里我们来介绍一下如何编写Promise代码。</p>
</div>
<div class="sect3">
<h4 id="__promise">1.3.1. 创建promise对象</h4>
<div class="paragraph">
<p>创建promise对象的流程如下所示。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>new Promise(fn)</code> 返回一个promise对象</p>
</li>
<li>
<p>在<code>fn</code> 中指定异步等处理</p>
<div class="ulist">
<ul>
<li>
<p>处理结果正常的话，调用<code>resolve(处理结果值)</code></p>
</li>
<li>
<p>处理结果错误的话，调用<code>reject(Error对象)</code></p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>按这个流程我们来实际编写下promise代码吧。</p>
</div>
<div class="paragraph">
<p>我们的任务是用Promise来通过异步处理方式来获取XMLHttpRequest(XHR)的数据。</p>
</div>
<div class="sect4">
<h5 id="__xhr_promise">创建XHR的promise对象</h5>
<div class="paragraph">
<p>首先，创建一个用Promise把XHR处理包装起来的名为 <code>getURL</code> 的函数。</p>
</div>
<div id="xhr-promise.js" class="listingblock executable">
<div class="title">xhr-promise.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">getURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onload</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.status === <span class="integer">200</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
<span class="comment">// 运行示例</span>
<span class="keyword">var</span> URL = <span class="string"><span class="delimiter">&quot;</span><span class="content">http://httpbin.org/get</span><span class="delimiter">&quot;</span></span>;
getURL(URL).then(<span class="keyword">function</span> <span class="function">onFulfilled</span>(value){
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span> <span class="function">onRejected</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>getURL</code> 只有在通过XHR取得结果状态为200时才会调用 <code>resolve</code> - 也就是只有数据取得成功时，而其他情况（取得失败）时则会调用 <code>reject</code> 方法。</p>
</div>
<div class="paragraph">
<p><code>resolve(req.responseText)</code> 在response的内容中加入了参数。
resolve方法的参数并没有特别的规则，基本上把要传给回调函数参数放进去就可以了。
( <code>then</code> 方法可以接收到这个参数值)</p>
</div>
<div class="paragraph">
<p>熟悉Node.js的人，经常会在写回调函数时将 <code>callback(error, response)</code> 的第一个参数设为error对象，而在Promise中resolve/reject则担当了这个职责（处理正常和异常的情况），所以
在resolve方法中只传一个response参数是没有问题的。</p>
</div>
<div class="paragraph">
<p>接下来我们来看一下<code>reject</code>函数。</p>
</div>
<div class="paragraph">
<p>XHR中 <code>onerror</code> 事件被触发的时候就是发生错误时，所以理所当然调用<code>reject</code>。
这里我们重点来看一下传给<code>reject</code>的值。</p>
</div>
<div class="paragraph">
<p>发生错误时要像这样 <code>reject(new Error(req.statusText));</code> ，创建一个Error对象后再将具体的值传进去。
传给<code>reject</code> 的参数也没有什么特殊的限制，一般只要是Error对象（或者继承自Error对象）就可以。</p>
</div>
<div class="paragraph">
<p>传给<code>reject</code> 的参数，其中一般是包含了reject原因的Error对象。
本次因为状态值不等于200而被reject，所以<code>reject</code> 中放入的是statusText。
（这个参数的值可以被 <code>then</code> 方法的第二个参数或者 <code>catch</code> 方法中使用）</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__promise_2">1.3.2. 编写promise对象处理方法</h4>
<div class="paragraph">
<p>让我们在实际中使用一下刚才创建的返回promise对象的函数</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">getURL(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://example.com/</span><span class="delimiter">&quot;</span></span>); <span class="comment">// =&gt; 返回promise对象</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如<a href="#promises-overview">Promises Overview</a> 中做的简单介绍一样，promise对象拥有几个实例方法，
我们使用这些实例方法来为promise对象创建依赖于promise的具体状态、并且只会被执行一次的回调函数。</p>
</div>
<div class="paragraph">
<p>为promise对象添加处理方法主要有以下两种</p>
</div>
<div class="ulist">
<ul>
<li>
<p>promise对象被 <strong>resolve</strong> 时的处理(onFulfilled)</p>
</li>
<li>
<p>promise对象被 <strong>reject</strong> 时的处理(onRejected)</p>
</li>
</ul>
</div>
<div id="promise-value-flow" class="imageblock">
<div class="content">
<img src="Ch1_WhatsPromises/img/promise-onFulfilled_onRejected.png" alt="promise-resolve-flow">
</div>
<div class="title">Figure 2. promise value flow</div>
</div>
<div class="paragraph">
<p>首先，我们来尝试一下为 <code>getURL</code> 通信成功并取到值时添加的处理函数。</p>
</div>
<div class="paragraph">
<p>此时所谓的 <em>通信成功</em> ，
指的就是在被resolve后， <em>promise对象变为FulFilled状态</em> 。</p>
</div>
<div class="paragraph">
<p>被<strong>resolve</strong>后的处理，可以在<a href="#promise.then"><code>.then</code></a> 方法中传入想要调用的函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> URL = <span class="string"><span class="delimiter">&quot;</span><span class="content">http://httpbin.org/get</span><span class="delimiter">&quot;</span></span>;
getURL(URL).then(<span class="keyword">function</span> <span class="function">onFulfilled</span>(value){ <i class="conum" data-value="1"></i><b>(1)</b>
    console.log(value);
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>为了方便理解我们把函数命名为 <code>onFulfilled</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="#xhr-promise.js">getURL函数</a> 中的 <code>resolve(req.responseText);</code> 会将promise对象变为resolve（Fulfilled）状态，
同时使用其值调用 <code>onFulfilled</code> 函数。</p>
</div>
<div class="paragraph">
<p>不过目前我们还没有对其中可能发生的错误做任何处理，
接下来，我们就来为 <code>getURL</code> 函数添加发生错误时的异常处理。</p>
</div>
<div class="paragraph">
<p>此时 <em>发生错误</em> ，
指的也就是reject后 <em>promise对象变为Rejected状态</em> 。</p>
</div>
<div class="paragraph">
<p>被<strong>reject</strong>后的处理，可以在<a href="#promise.then"><code>.then</code> 的第二个参数</a> 或者是在 <a href="#promise.catch"><code>.catch</code></a> 方法中设置想要调用的函数。</p>
</div>
<div class="paragraph">
<p>把下面reject时的处理加入到刚才的代码，如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> URL = <span class="string"><span class="delimiter">&quot;</span><span class="content">http://httpbin.org/status/500</span><span class="delimiter">&quot;</span></span>; <i class="conum" data-value="1"></i><b>(1)</b>
getURL(URL).then(<span class="keyword">function</span> <span class="function">onFulfilled</span>(value){
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span> <span class="function">onRejected</span>(error){ <i class="conum" data-value="2"></i><b>(2)</b>
    console.error(error);
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>服务端返回的状态码为500</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>为了方便理解函数被命名为 <code>onRejected</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在<code>getURL</code> 的处理中发生任何异常，或者被明确reject的情况下，
该异常原因（Error对象）会作为 <a href="#promise.catch"><code>.catch</code></a> 方法的参数被调用。</p>
</div>
<div class="paragraph">
<p>其实 <a href="#promise.catch"><code>.catch</code></a>只是 <code>promise.then(undefined, onRejected)</code> 的别名而已，
如下代码也可以完成同样的功能。</p>
</div>
<div id="catch-as-alias" class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">getURL(URL).then(onFulfilled, onRejected);<i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>onFulfilled, onRejected 是和刚才相同的函数</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一般说来，使用<a href="#promise.catch"><code>.catch</code></a>来将resolve和reject处理分开来写是比较推荐的做法，
这两者的区别会在<a href="#then-or-catch">then和catch的区别</a>中再做详细介绍。</p>
</div>
<div class="sect4">
<h5 id="__7">总结</h5>
<div class="paragraph">
<p>在本章我们简单介绍了以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用 <code>new Promise</code> 方法创建promise对象</p>
</li>
<li>
<p>用<a href="#promise.then"><code>.then</code></a> 或 <a href="#promise.catch"><code>.catch</code></a> 添加promise对象的处理函数</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>到此为止我们已经学习了Promise的基本写法。
其他很多处理都是由此基本语法延伸的，也使用了Promise提供的一些静态方法来实现。</p>
</div>
<div class="paragraph">
<p>实际上即使使用回调方式的写法也能完成上面同样的工作，而使用Promise方式的话有什么优点么？在本小节中我们没有讲到两者的对比及Promise的优点。在接下来的章节中，我们将会对Promise优点之一，即错误处理机制进行介绍，以及和传统的回调方式的对比。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter2-how-to-write-promise">2. Chapter.2 - 实战Promise</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章我们将会学习Promise提供的各种方法以及如何进行错误处理。</p>
</div>
<div class="sect2">
<h3 id="ch2-promise-resolve">2.1. Promise.resolve</h3>
<div class="paragraph">
<p>一般情况下我们都会使用 <code>new Promise()</code> 来创建promise对象，但是除此之外我们也可以使用其他方法。</p>
</div>
<div class="paragraph">
<p>在这里，我们将会学习如何使用 <a href="#Promise.resolve"><code>Promise.resolve</code></a> 和 <a href="#Promise.reject"><code>Promise.reject</code></a>这两个方法。</p>
</div>
<div class="sect3">
<h4 id="_new_promise">2.1.1. new Promise的快捷方式</h4>
<div class="paragraph">
<p>静态方法<a href="#Promise.resolve"><code>Promise.resolve(value)</code></a> 可以认为是
<code>new Promise()</code> 方法的快捷方式。</p>
</div>
<div class="paragraph">
<p>比如 <code>Promise.resolve(42);</code> 可以认为是以下代码的语法糖。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve){
    resolve(<span class="integer">42</span>);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这段代码中的 <code>resolve(42);</code> 会让这个promise对象立即进入确定（即resolved）状态，并将 <code>42</code> 传递给后面then里所指定的 <code>onFulfilled</code> 函数。</p>
</div>
<div class="paragraph">
<p>方法 <code>Promise.resolve(value);</code> 的返回值也是一个promise对象，所以我们可以像下面那样接着对其返回值进行 <code>.then</code> 调用。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Promise.resolve(<span class="integer">42</span>).then(<span class="keyword">function</span>(value){
    console.log(value);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#Promise.resolve">Promise.resolve</a>作为 <code>new Promise()</code> 的快捷方式，在进行promise对象的初始化或者编写测试代码的时候都非常方便。</p>
</div>
</div>
<div class="sect3">
<h4 id="_thenable">2.1.2. Thenable</h4>
<div class="paragraph">
<p><code>Promise.resolve</code> 方法另一个作用就是将 <a href="#Thenable">thenable</a> 对象转换为promise对象。</p>
</div>
<div class="paragraph">
<p><a href="#es6-promises">ES6 Promises</a>里提到了<a href="#Thenable">Thenable</a>这个概念，简单来说它就是一个非常类似promise的东西。</p>
</div>
<div class="paragraph">
<p>就像我们有时称具有 <code>.length</code> 方法的非数组对象为Array like一样，thenable指的是一个具有 <code>.then</code> 方法的对象。</p>
</div>
<div class="paragraph">
<p>这种将thenable对象转换为promise对象的机制要求thenable对象所拥有的 <code>then</code> 方法应该和Promise所拥有的 <code>then</code> 方法具有同样的功能和处理过程，在将thenable对象转换为promise对象的时候，还会巧妙的利用thenable对象原来具有的 <code>then</code> 方法。</p>
</div>
<div class="paragraph">
<p>到底什么样的对象能算是thenable的呢，最简单的例子就是
<a href="https://api.jquery.com/jQuery.ajax/">jQuery.ajax()</a>，它的返回值就是thenable的。</p>
</div>
<div class="paragraph">
<p>因为<code>jQuery.ajax()</code> 的返回值是 <a href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR Object</a> 对象，这个对象具有 <code>.then</code> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="predefined">$</span>.ajax(<span class="string"><span class="delimiter">'</span><span class="content">/json/comment.json</span><span class="delimiter">'</span></span>);<span class="comment">// =&gt; 拥有 `.then` 方法的对象</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个thenable的对象可以使用 <code>Promise.resolve</code> 来转换为一个promise对象。</p>
</div>
<div class="paragraph">
<p>变成了promise对象的话，就能直接使用 <code>then</code> 或者 <code>catch</code> 等这些在
<a href="#es6-promises">ES6 Promises</a>里定义的方法了。</p>
</div>
<div class="listingblock">
<div class="title">将thenable对象转换promise对象</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = Promise.resolve(<span class="predefined">$</span>.ajax(<span class="string"><span class="delimiter">'</span><span class="content">/json/comment.json</span><span class="delimiter">'</span></span>));<span class="comment">// =&gt; promise对象</span>
promise.then(<span class="keyword">function</span>(value){
   console.log(value);
});</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="title">jQuery和thenable</div>
<div class="paragraph">
<p><a href="https://api.jquery.com/jQuery.ajax/">jQuery.ajax()</a>的返回值是一个具有 <code>.then</code> 方法的 <a href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR Object</a>对象，这个对象继承了来自 <a href="http://api.jquery.com/category/deferred-object/">Deferred Object</a> 的方法和属性。</p>
</div>
<div class="paragraph">
<p>但是Deferred Object并没有遵循<a href="#promises-aplus">Promises/A+</a>或<a href="#es6-promises">ES6 Promises</a>标准，所以即使看上去这个对象转换成了一个promise对象，但是会出现缺失部分信息的问题。</p>
</div>
<div class="paragraph">
<p>这个问题的根源在于jQuery的 <a href="http://api.jquery.com/category/deferred-object/">Deferred Object</a> 的 <code>then</code> 方法机制与promise不同。</p>
</div>
<div class="paragraph">
<p>所以我们应该注意，即使一个对象具有 <code>.then</code> 方法，也不一定就能作为ES6 Promises对象使用。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.html5rocks.com/en/tutorials/es6/promises/#toc-lib-compatibility">JavaScript Promises: There and back again - HTML5 Rocks</a></p>
</li>
<li>
<p><a href="http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/">You&#39;re Missing the Point of Promises</a></p>
</li>
<li>
<p><a href="https://twitter.com/hirano_y_aa/status/398851806383452160">https://twitter.com/hirano_y_aa/status/398851806383452160</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>Promise.resolve</code> 只使用了共通的方法 <code>then</code> ，提供了在不同的类库之间进行promise对象互相转换的功能。</p>
</div>
<div class="paragraph">
<p>这种转换为thenable的功能在之前是通过使用 <code>Promise.cast</code> 来完成的，从它的名字我们也不难想象它的功能是什么。</p>
</div>
<div class="paragraph">
<p>除了在编写使用Promise的类库等软件时需要对Thenable有所了解之外，通常作为end-user使用的时候，我们可能不会用到此功能。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>我们会在后面第4章的<a href="#resolve-thenable">Promise.resolve和Thenable</a>中进行详细的说明，介绍一下结合使用了Thenable和Promise.resolve的具体例子。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>简单总结一下 <code>Promise.resolve</code> 方法的话，可以认为它的作用就是将传递给它的参数填充（Fulfilled）到promise对象后并返回这个promise对象。</p>
</div>
<div class="paragraph">
<p>此外，Promise的很多处理内部也是使用了 <code>Promise.resolve</code> 算法将值转换为promise对象后再进行处理的。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise-reject">2.2. Promise.reject</h3>
<div class="paragraph">
<p><a href="#Promise.reject"><code>Promise.reject(error)</code></a>是和
<a href="#Promise.resolve"><code>Promise.resolve(value)</code></a> 类似的静态方法，是 <code>new Promise()</code> 方法的快捷方式。</p>
</div>
<div class="paragraph">
<p>比如 <code>Promise.reject(new Error("出错了"))</code> 就是下面代码的语法糖形式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve,reject){
    reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">出错了</span><span class="delimiter">&quot;</span></span>));
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码的功能是调用该promise对象通过then指定的 <code>onRejected</code> 函数，并将错误（Error）对象传递给这个 <code>onRejected</code> 函数。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">BOOM!</span><span class="delimiter">&quot;</span></span>)).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>它和<a href="#Promise.resolve"><code>Promise.resolve(value)</code></a> 的不同之处在于promise内调用的函数是reject而不是resolve，这在编写测试代码或者进行debug时，说不定会用得上。</p>
</div>
</div>
<div class="sect2">
<h3 id="promise-is-always-async">2.3. 专栏: Promise只能进行异步操作？</h3>
<div class="paragraph">
<p>在使用<a href="#Promise.resolve"><code>Promise.resolve(value)</code></a> 等方法的时候，如果promise对象立刻就能进入resolve状态的话，那么你是不是觉得 <code>.then</code> 里面指定的方法就是同步调用的呢？</p>
</div>
<div class="paragraph">
<p>实际上， <code>.then</code> 中指定的方法调用是异步进行的。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve){
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">inner promise</span><span class="delimiter">&quot;</span></span>); <span class="comment">// 1</span>
    resolve(<span class="integer">42</span>);
});
promise.then(<span class="keyword">function</span>(value){
    console.log(value); <span class="comment">// 3</span>
});
console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">outer promise</span><span class="delimiter">&quot;</span></span>); <span class="comment">// 2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>执行上面的代码会输出下面的log，从这些log我们清楚地知道了上面代码的执行顺序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>inner promise // 1
outer promise // 2
42            // 3</pre>
</div>
</div>
<div class="paragraph">
<p>由于JavaScript代码会按照文件的从上到下的顺序执行，所以最开始 <code>&lt;1&gt;</code> 会执行，然后是 <code>resolve(42);</code> 被执行。这时候 <code>promise</code> 对象的已经变为确定状态，FulFilled被设置为了 <code>42</code> 。</p>
</div>
<div class="paragraph">
<p>下面的代码 <code>promise.then</code> 注册了 <code>&lt;3&gt;</code> 这个回调函数，这是本专栏的焦点问题。</p>
</div>
<div class="paragraph">
<p>由于 <code>promise.then</code> 执行的时候promise对象已经是确定状态，从程序上说对回调函数进行同步调用也是行得通的。</p>
</div>
<div class="paragraph">
<p>但是即使在调用 <code>promise.then</code> 注册回调函数的时候promise对象已经是确定的状态，Promise也会以异步的方式调用该回调函数，这是在Promise设计上的规定方针。</p>
</div>
<div class="paragraph">
<p>因此 <code>&lt;2&gt;</code> 会最先被调用，最后才会调用回调函数 <code>&lt;3&gt;</code> 。</p>
</div>
<div class="paragraph">
<p>为什么要对明明可以以同步方式进行调用的函数，非要使用异步的调用方式呢？</p>
</div>
<div class="sect3">
<h4 id="__8">2.3.1. 同步调用和异步调用同时存在导致的混乱</h4>
<div class="paragraph">
<p>其实在Promise之外也存在这个问题，这里我们以一般的使用情况来考虑此问题。</p>
</div>
<div class="paragraph">
<p>这个问题的本质是接收回调函数的函数，会根据具体的执行情况，可以选择是以同步还是异步的方式对回调函数进行调用。</p>
</div>
<div class="paragraph">
<p>下面我们以 <code>onReady(fn)</code> 为例进行说明，这个函数会接收一个回调函数进行处理。</p>
</div>
<div id="mixed-onready.js" class="listingblock executable">
<div class="title">mixed-onready.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">onReady</span>(fn) {
    <span class="keyword">var</span> readyState = document.readyState;
    <span class="keyword">if</span> (readyState === <span class="string"><span class="delimiter">'</span><span class="content">interactive</span><span class="delimiter">'</span></span> || readyState === <span class="string"><span class="delimiter">'</span><span class="content">complete</span><span class="delimiter">'</span></span>) {
        fn();
    } <span class="keyword">else</span> {
        window.addEventListener(<span class="string"><span class="delimiter">'</span><span class="content">DOMContentLoaded</span><span class="delimiter">'</span></span>, fn);
    }
}
onReady(<span class="keyword">function</span> () {
    console.log(<span class="string"><span class="delimiter">'</span><span class="content">DOM fully loaded and parsed</span><span class="delimiter">'</span></span>);
});
console.log(<span class="string"><span class="delimiter">'</span><span class="content">==Starting==</span><span class="delimiter">'</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#mixed-onready.js">mixed-onready.js</a>会根据执行时DOM是否已经装载完毕来决定是对回调函数进行同步调用还是异步调用。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">如果在调用onReady之前DOM已经载入的话</dt>
<dd>
<p>对回调函数进行同步调用</p>
</dd>
<dt class="hdlist1">如果在调用onReady之前DOM还没有载入的话</dt>
<dd>
<p>通过注册 <code>DOMContentLoaded</code> 事件监听器来对回调函数进行异步调用</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>因此，如果这段代码在源文件中出现的位置不同，在控制台上打印的log消息顺序也会不同。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，我们可以选择统一使用异步调用的方式。</p>
</div>
<div id="async-onready.js" class="listingblock executable">
<div class="title">async-onready.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">onReady</span>(fn) {
    <span class="keyword">var</span> readyState = document.readyState;
    <span class="keyword">if</span> (readyState === <span class="string"><span class="delimiter">'</span><span class="content">interactive</span><span class="delimiter">'</span></span> || readyState === <span class="string"><span class="delimiter">'</span><span class="content">complete</span><span class="delimiter">'</span></span>) {
        setTimeout(fn, <span class="integer">0</span>);
    } <span class="keyword">else</span> {
        window.addEventListener(<span class="string"><span class="delimiter">'</span><span class="content">DOMContentLoaded</span><span class="delimiter">'</span></span>, fn);
    }
}
onReady(<span class="keyword">function</span> () {
    console.log(<span class="string"><span class="delimiter">'</span><span class="content">DOM fully loaded and parsed</span><span class="delimiter">'</span></span>);
});
console.log(<span class="string"><span class="delimiter">'</span><span class="content">==Starting==</span><span class="delimiter">'</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于这个问题，在 <a href="http://effectivejs.com/">Effective JavaScript</a> 的 <strong>第67项 不要对异步回调函数进行同步调用</strong> 中也有详细介绍。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="ulist">
<ul>
<li>
<p>绝对不能对异步回调函数（即使在数据已经就绪）进行同步调用。</p>
</li>
<li>
<p>如果对异步回调函数进行同步调用的话，处理顺序可能会与预期不符，可能带来意料之外的后果。</p>
</li>
<li>
<p>对异步回调函数进行同步调用，还可能导致栈溢出或异常处理错乱等问题。</p>
</li>
<li>
<p>如果想在将来某时刻调用异步回调函数的话，可以使用 <code>setTimeout</code> 等异步API。</p>
</li>
</ul>
</div>
</blockquote>
<div class="attribution">
<cite>Effective JavaScript</cite><br>
&#8212; David Herman
</div>
</div>
<div class="paragraph">
<p>前面我们看到的 <code>promise.then</code> 也属于此类，为了避免上述中同时使用同步、异步调用可能引起的混乱问题，Promise在规范上规定 <strong>Promise只能使用异步调用方式</strong> 。</p>
</div>
<div class="paragraph">
<p>最后，如果将上面的 <code>onReady</code> 函数用Promise重写的话，代码如下面所示。</p>
</div>
<div id="onready-as-promise.js" class="listingblock executable">
<div class="title">onready-as-promise.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">onReadyPromise</span>() {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="keyword">var</span> readyState = document.readyState;
        <span class="keyword">if</span> (readyState === <span class="string"><span class="delimiter">'</span><span class="content">interactive</span><span class="delimiter">'</span></span> || readyState === <span class="string"><span class="delimiter">'</span><span class="content">complete</span><span class="delimiter">'</span></span>) {
            resolve();
        } <span class="keyword">else</span> {
            window.addEventListener(<span class="string"><span class="delimiter">'</span><span class="content">DOMContentLoaded</span><span class="delimiter">'</span></span>, resolve);
        }
    });
}
onReadyPromise().then(<span class="keyword">function</span> () {
    console.log(<span class="string"><span class="delimiter">'</span><span class="content">DOM fully loaded and parsed</span><span class="delimiter">'</span></span>);
});
console.log(<span class="string"><span class="delimiter">'</span><span class="content">==Starting==</span><span class="delimiter">'</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于Promise保证了每次调用都是以异步方式进行的，所以我们在实际编码中不需要调用 <code>setTimeout</code> 来自己实现异步调用。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise.then">2.4. Promise#then</h3>
<div class="paragraph">
<p>在前面的章节里我们对Promise基本的实例方法 <code>then</code> 和 <code>catch</code> 的使用方法进行了说明。</p>
</div>
<div class="paragraph">
<p>这其中，我想大家已经认识了 <code>.then().catch()</code> 这种链式方法的写法了，其实在Promise里可以将任意个方法连在一起作为一个方法链（method chain）。</p>
</div>
<div class="listingblock">
<div class="title">promise可以写成方法链的形式</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">aPromise.then(<span class="keyword">function</span> <span class="function">taskA</span>(value){
<span class="comment">// task A</span>
}).then(<span class="keyword">function</span> <span class="function">taskB</span>(vaue){
<span class="comment">// task B</span>
}).<span class="keyword">catch</span>(<span class="keyword">function</span> <span class="function">onRejected</span>(error){
    console.log(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果把在 <code>then</code> 中注册的每个回调函数称为task的话，那么我们就可以通过Promise方法链方式来编写能以taskA &#8594; task B 这种流程进行处理的逻辑了。</p>
</div>
<div class="paragraph">
<p>Promise方法链这种叫法有点长（其实是在日语里有点长，中文还可以 --译者注），因此后面我们会简化为 <a href="#promise-chain">promise chain</a> 这种叫法。</p>
</div>
<div class="paragraph">
<p>Promise之所以适合编写异步处理较多的应用，promise chain可以算得上是其中的一个原因吧。</p>
</div>
<div class="paragraph">
<p>在本小节，我们将主要针对使用 <code>then</code> 的promise chain的行为和流程进行学习。</p>
</div>
<div class="sect3">
<h4 id="_promise_chain">2.4.1. promise chain</h4>
<div class="paragraph">
<p>在第一章 <a href="#promise-chain">promise chain</a> 里我们看到了一个很简单的
then &#8594; catch 的例子，如果我们将方法链的长度变得更长的话，那在每个promise对象中注册的onFulfilled和onRejected将会怎样执行呢？</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
promise chain - 即方法链越短越好。
在这个例子里我们是为了方便说明才选择了较长的方法链。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我们先来看看下面这样的promise chain。</p>
</div>
<div id="promise-then-catch-flow.js" class="listingblock executable">
<div class="title">promise-then-catch-flow.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">taskA</span>() {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Task A</span><span class="delimiter">&quot;</span></span>);
}
<span class="keyword">function</span> <span class="function">taskB</span>() {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Task B</span><span class="delimiter">&quot;</span></span>);
}
<span class="keyword">function</span> <span class="function">onRejected</span>(error) {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Catch Error: A or B</span><span class="delimiter">&quot;</span></span>, error);
}
<span class="keyword">function</span> <span class="function">finalTask</span>() {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Final Task</span><span class="delimiter">&quot;</span></span>);
}

<span class="keyword">var</span> promise = Promise.resolve();
promise
    .then(taskA)
    .then(taskB)
    .<span class="keyword">catch</span>(onRejected)
    .then(finalTask);</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面代码中的promise chain的执行流程，如果用一张图来描述一下的话，像下面的图那样。</p>
</div>
<div id="promise-then-catch-flow.png" class="imageblock">
<div class="content">
<img src="Ch2_HowToWrite/img/promise-then-catch-flow.png" alt="promise-then-catch-flow">
</div>
<div class="title">Figure 3. promise-then-catch-flow.js附图</div>
</div>
<div class="paragraph">
<p>在 <a href="#promise-then-catch-flow.js">上述代码</a> 中，我们没有为 <code>then</code> 方法指定第二个参数(onRejected)，也可以像下面这样来理解。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>then</code></dt>
<dd>
<p>注册onFulfilled时的回调函数</p>
</dd>
<dt class="hdlist1"><code>catch</code></dt>
<dd>
<p>注册onRejected时的回调函数</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>再看一下 <a href="#promise-then-catch-flow.png">上面的流程图</a> 的话，我们会发现 <em>Task A</em> 和 <em>Task B</em> 都有指向  <em>onRejected</em> 的线出来。</p>
</div>
<div class="paragraph">
<p>这些线的意思是在 <em>Task A</em> 或 <em>Task B</em> 的处理中，在下面的情况下就会调用 <em>onRejected</em> 方法。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>发生异常的时候</p>
</li>
<li>
<p>返回了一个Rejected状态的promise对象</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 <a href="#how-to-write-promise">第一章</a> 中我们已经看到，Promise中的处理习惯上都会采用 <code>try-catch</code> 的风格，当发生异常的时候，会被 <code>catch</code> 捕获并被由在此函数注册的回调函数进行错误处理。</p>
</div>
<div class="paragraph">
<p>另一种异常处理策略是通过 <em>返回一个Rejected状态的promise对象</em> 来实现的，这种方法不通过使用 <code>throw</code> 就能在promise chain中对 <code>onRejected</code> 进行调用。</p>
</div>
<div class="paragraph">
<p>关于这种方法由于和本小节关系不大就不在这里详述了，大家可以参考一下第4章 <a href="#not-throw-use-reject">使用reject而不是throw</a> 中的内容。</p>
</div>
<div class="paragraph">
<p>此外在promise chain中，由于在 <em>onRejected</em> 和 <em>Final Task</em> 后面没有 <code>catch</code> 处理了，因此在这两个Task中如果出现异常的话将不会被捕获，这点需要注意一下。</p>
</div>
<div class="paragraph">
<p>下面我们再来看一个具体的关于 <em>Task A</em> &#8594; <em>onRejected</em> 的例子。</p>
</div>
<div class="sect4">
<h5 id="_task_a">Task A产生异常的例子</h5>
<div class="paragraph">
<p><em>Task A</em> 处理中发生异常的话，会按照TaskA &#8594; onRejected &#8594; FinalTask 这个流程来进行处理。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch2_HowToWrite/img/promise-taska-rejected-flow.png" alt="promise taska rejected flow">
</div>
<div class="title">Figure 4. Task A产生异常时的示意图</div>
</div>
<div class="paragraph">
<p>将上面流程写成代码的话如下所示。</p>
</div>
<div id="promise-then-taska-throw.js" class="listingblock executable">
<div class="title">promise-then-taska-throw.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">taskA</span>() {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Task A</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">throw Error @ Task A</span><span class="delimiter">&quot;</span></span>)
}
<span class="keyword">function</span> <span class="function">taskB</span>() {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Task B</span><span class="delimiter">&quot;</span></span>);<span class="comment">// 不会被调用</span>
}
<span class="keyword">function</span> <span class="function">onRejected</span>(error) {
    console.log(error);<span class="comment">// =&gt; &quot;throw Error @ Task A&quot;</span>
}
<span class="keyword">function</span> <span class="function">finalTask</span>() {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Final Task</span><span class="delimiter">&quot;</span></span>);
}

<span class="keyword">var</span> promise = Promise.resolve();
promise
    .then(taskA)
    .then(taskB)
    .<span class="keyword">catch</span>(onRejected)
    .then(finalTask);</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行这段代码我们会发现 <em>Task B</em> 是不会被调用的。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在本例中我们在taskA中使用了 <code>throw</code> 方法故意制造了一个异常。但在实际中想主动进行onRejected调用的时候，应该返回一个Rejected状态的promise对象。关于这种两种方法的异同，请参考 <a href="#not-throw-use-reject">使用reject而不是throw</a> 中的讲解。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_promise_chain_2">2.4.2. promise chain 中如何传递参数</h4>
<div class="paragraph">
<p>前面例子中的Task都是相互独立的，只是被简单调用而已。</p>
</div>
<div class="paragraph">
<p>这时候如果 Task A 想给 Task B 传递一个参数该怎么办呢？</p>
</div>
<div class="paragraph">
<p>答案非常简单，那就是在 Task A 中 <code>return</code> 的返回值，会在 Task B 执行时传给它。</p>
</div>
<div class="paragraph">
<p>我们还是先来看一个具体例子吧。</p>
</div>
<div id="promise-then-passing-value.js" class="listingblock executable">
<div class="title">promise-then-passing-value.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">doubleUp</span>(value) {
    <span class="keyword">return</span> value * <span class="integer">2</span>;
}
<span class="keyword">function</span> <span class="function">increment</span>(value) {
    <span class="keyword">return</span> value + <span class="integer">1</span>;
}
<span class="keyword">function</span> <span class="function">output</span>(value) {
    console.log(value);<span class="comment">// =&gt; (1 + 1) * 2</span>
}

<span class="keyword">var</span> promise = Promise.resolve(<span class="integer">1</span>);
promise
    .then(increment)
    .then(doubleUp)
    .then(output)
    .<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
        <span class="comment">// promise chain中出现异常的时候会被调用</span>
        console.error(error);
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码的入口函数是 <code>Promise.resolve(1);</code> ，整体的promise chain执行流程如下所示。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>Promise.resolve(1);</code> 传递 1 给 <code>increment</code> 函数</p>
</li>
<li>
<p>函数 <code>increment</code> 对接收的参数进行 +1 操作并返回（通过<code>return</code>）</p>
</li>
<li>
<p>这时参数变为2，并再次传给 <code>doubleUp</code> 函数</p>
</li>
<li>
<p>最后在函数 <code>output</code> 中打印结果</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch2_HowToWrite/img/promise-then-passing-value.png" alt="promise-then-passing-value">
</div>
<div class="title">Figure 5. promise-then-passing-value.js示意图</div>
</div>
<div class="paragraph">
<p>每个方法中 <code>return</code> 的值不仅只局限于字符串或者数值类型，也可以是对象或者promise对象等复杂类型。</p>
</div>
<div class="paragraph">
<p>return的值会由 <code>Promise.resolve(return的返回值);</code> 进行相应的包装处理，因此不管回调函数中会返回一个什么样的值，最终 <code>then</code> 的结果都是返回一个新创建的promise对象。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
关于这部分内容可以参考 <a href="#then-return-new-promise">专栏: 每次调用then都会返回一个新创建的promise对象</a> ，那里也对一些常见错误进行了介绍。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>也就是说， <code>Promise#then</code> 不仅仅是注册一个回调函数那么简单，它还会将回调函数的返回值进行变换，创建并返回一个promise对象。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise-catch">2.5. Promise#catch</h3>
<div class="paragraph">
<p>在 <a href="#ch2-promise.then">前面的Promise#then</a> 的章节里，我们已经简单地使用了 <code>Promise#catch</code> 方法。</p>
</div>
<div class="paragraph">
<p>这里我们再说一遍，实际上 <a href="#promise.catch">Promise#catch</a> 只是 <code>promise.then(undefined, onRejected);</code> 方法的一个别名而已。
也就是说，这个方法用来注册当promise对象状态变为Rejected时的回调函数。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
关于如何根据场景使用 <a href="#promise.then">Promise#then</a> 和 <a href="#promise.catch">Promise#catch</a> 可以参考
 <a href="#then-or-catch">then or catch?</a> 中介绍的内容。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_ie8">2.5.1. IE8的问题</h4>
<div class="paragraph">
<p><span class="image"><a class="image" href="https://ci.testling.com/azu/promise-catch-error"><img src="Ch2_HowToWrite/img/promise-catch-error.png" alt="Build Status"></a></span></p>
</div>
<div class="paragraph">
<p>上面的这张图，是下面这段代码在使用 <a href="https://github.com/jakearchibald/es6-promise">polyfill</a> 的情况下在个浏览器上执行的结果。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>polyfill是一个支持在不具备某一功能的浏览器上使用该功能的Library。
这里我们使用的例子则来源于 <a href="https://github.com/jakearchibald/es6-promise">jakearchibald/es6-promise</a> 。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock executable">
<div class="title">Promise#catch的运行结果</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>));
promise.<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们在各种浏览器中执行这段代码，那么在IE8及以下版本则会出现 <strong>identifier not found</strong> 的语法错误。</p>
</div>
<div class="paragraph">
<p>这是怎么回事呢？ 实际上这和 <code>catch</code> 是ECMAScript的 <a href="http://mothereff.in/js-properties#catch">保留字</a> (Reserved Word)有关。</p>
</div>
<div class="paragraph">
<p>在ECMAScript 3中保留字是不能作为对象的属性名使用的。
而IE8及以下版本都是基于ECMAScript 3实现的，因此不能将 <code>catch</code> 作为属性来使用，也就不能编写类似 <code>promise.catch()</code> 的代码，因此就出现了 <strong>identifier not found</strong> 这种语法错误了。</p>
</div>
<div class="paragraph">
<p>而现在的浏览器都是基于ECMAScript 5的，而在ECMAScript 5中保留字都属于 <a href="http://es5.github.io/#x7.6">IdentifierName</a> ，也可以作为属性名使用了。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在ECMAScript5中保留字也不能作为 <a href="http://es5.github.io/#x7.6">Identifier</a> 即变量名或方法名使用。
如果我们定义了一个名为 <code>for</code> 的变量的话，那么就不能和循环语句的 <code>for</code> 区分了。
而作为属性名的话，我们还是很容易区分 <code>object.for</code> 和 <code>for</code> 的，仔细想想我们就应该能接受将保留字作为属性名来使用了。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当然，我们也可以想办法回避这个ECMAScript 3保留字带来的问题。</p>
</div>
<div class="paragraph">
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation">点标记法（dot notation）</a> 要求对象的属性必须是有效的标识符（在ECMAScript 3中则不能使用保留字），</p>
</div>
<div class="paragraph">
<p>但是使用 <a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Bracket_notation">中括号标记法（bracket notation）</a>的话，则可以将非合法标识符作为对象的属性名使用。</p>
</div>
<div class="paragraph">
<p>也就是说，上面的代码如果像下面这样重写的话，就能在IE8及以下版本的浏览器中运行了（当然还需要polyfill）。</p>
</div>
<div class="listingblock executable">
<div class="title">解决Promise#catch标识符冲突问题</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>));
promise[<span class="string"><span class="delimiter">&quot;</span><span class="content">catch</span><span class="delimiter">&quot;</span></span>](<span class="keyword">function</span> (error) {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者我们不单纯的使用 <code>catch</code> ，而是使用 <code>then</code> 也是可以避免这个问题的。</p>
</div>
<div class="listingblock executable">
<div class="title">使用Promise#then代替Promise#catch</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>));
promise.then(<span class="predefined-constant">undefined</span>, <span class="keyword">function</span> (error) {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <code>catch</code> 标识符可能会导致问题出现，因此一些类库（Library）也采用了 <code>caught</code> 作为函数名，而函数要完成的工作是一样的。</p>
</div>
<div class="paragraph">
<p>而且很多压缩工具自带了将 <code>promise.catch</code> 转换为 <code>promise["catch"]</code> 的功能，
所以可能不经意之间也能帮我们解决这个问题。</p>
</div>
<div class="paragraph">
<p>如果各位读者需要支持IE8及以下版本的浏览器的话，那么一定要将这个 <code>catch</code> 问题牢记在心中。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="then-return-new-promise">2.6. 专栏: 每次调用then都会返回一个新创建的promise对象</h3>
<div class="paragraph">
<p>从代码上乍一看， <code>aPromise.then(...).catch(...)</code> 像是针对最初的 <code>aPromise</code> 对象进行了一连串的方法链调用。</p>
</div>
<div class="paragraph">
<p>然而实际上不管是 <code>then</code> 还是 <code>catch</code> 方法调用，都返回了一个新的promise对象。</p>
</div>
<div class="paragraph">
<p>下面我们就来看看如何确认这两个方法返回的到底是不是新的promise对象。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> aPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
    resolve(<span class="integer">100</span>);
});
<span class="keyword">var</span> thenPromise = aPromise.then(<span class="keyword">function</span> (value) {
    console.log(value);
});
<span class="keyword">var</span> catchPromise = thenPromise.<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    console.error(error);
});
console.log(aPromise !== thenPromise); <span class="comment">// =&gt; true</span>
console.log(thenPromise !== catchPromise);<span class="comment">// =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>===</code> 是严格相等比较运算符，我们可以看出这三个对象都是互不相同的，这也就证明了 <code>then</code> 和 <code>catch</code> 都返回了和调用者不同的promise对象。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch2_HowToWrite/img/then_catch.png" alt="Then Catch flow">
</div>
</div>
<div class="paragraph">
<p>我们在对Promise进行扩展的时候需要牢牢记住这一点，否则稍不留神就有可能对错误的promise对象进行了处理。</p>
</div>
<div class="paragraph">
<p>如果我们知道了 <code>then</code> 方法每次都会创建并返回一个新的promise对象的话，那么我们就应该不难理解下面代码中对 <code>then</code> 的使用方式上的差别了。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="comment">// 1: 对同一个promise对象同时调用 `then` 方法</span>
<span class="keyword">var</span> aPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
    resolve(<span class="integer">100</span>);
});
aPromise.then(<span class="keyword">function</span> (value) {
    <span class="keyword">return</span> value * <span class="integer">2</span>;
});
aPromise.then(<span class="keyword">function</span> (value) {
    <span class="keyword">return</span> value * <span class="integer">2</span>;
});
aPromise.then(<span class="keyword">function</span> (value) {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">1: </span><span class="delimiter">&quot;</span></span> + value); <span class="comment">// =&gt; 100</span>
})

<span class="comment">// vs</span>

<span class="comment">// 2: 对 `then` 进行 promise chain 方式进行调用</span>
<span class="keyword">var</span> bPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
    resolve(<span class="integer">100</span>);
});
bPromise.then(<span class="keyword">function</span> (value) {
    <span class="keyword">return</span> value * <span class="integer">2</span>;
}).then(<span class="keyword">function</span> (value) {
    <span class="keyword">return</span> value * <span class="integer">2</span>;
}).then(<span class="keyword">function</span> (value) {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">2: </span><span class="delimiter">&quot;</span></span> + value); <span class="comment">// =&gt; 100 * 2 * 2</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>第1种写法中并没有使用promise的方法链方式，这在Promise中是应该极力避免的写法。这种写法中的 <code>then</code> 调用几乎是在同时开始执行的，而且传给每个 <code>then</code> 方法的 <code>value</code> 值都是 <code>100</code> 。</p>
</div>
<div class="paragraph">
<p>第2中写法则采用了方法链的方式将多个 <code>then</code> 方法调用串连在了一起，各函数也会严格按照 resolve &#8594; then &#8594; then &#8594; then 的顺序执行，并且传给每个 <code>then</code> 方法的 <code>value</code> 的值都是前一个promise对象通过 <code>return</code> 返回的值。</p>
</div>
<div class="paragraph">
<p>下面是一个由方法1中的 <code>then</code> 用法导致的比较容易出现的很有代表性的反模式的例子。</p>
</div>
<div class="listingblock">
<div class="title">✘ <code>then</code> 的错误使用方法</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">badAsyncCall</span>() {
    <span class="keyword">var</span> promise = Promise.resolve();
    promise.then(<span class="keyword">function</span>() {
        <span class="comment">// 任意处理</span>
        <span class="keyword">return</span> newVar;
    });
    <span class="keyword">return</span> promise;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种写法有很多问题，首先在 <code>promise.then</code> 中产生的异常不会被外部捕获，此外，也不能得到 <code>then</code> 的返回值，即使其有返回值。</p>
</div>
<div class="paragraph">
<p>由于每次 <code>promise.then</code> 调用都会返回一个新创建的promise对象，因此需要像上述方式2那样，采用promise chain的方式将调用进行链式化，修改后的代码如下所示。</p>
</div>
<div class="listingblock">
<div class="title"><code>then</code> 返回返回新创建的promise对象</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">anAsyncCall</span>() {
    <span class="keyword">var</span> promise = Promise.resolve();
    <span class="keyword">return</span> promise.then(<span class="keyword">function</span>() {
        <span class="comment">// 任意处理</span>
        <span class="keyword">return</span> newVar;
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于这些反模式，详细内容可以参考 <a href="http://taoofcode.net/promise-anti-patterns/">Promise Anti-patterns</a> 。</p>
</div>
<div class="paragraph">
<p>这种函数的行为贯穿在Promise整体之中，
包括我们后面要进行说明的 <a href="#ch2-promise-all">Promise.all</a> 和 <a href="#ch2-promise-race">Promise.race</a> ，他们都会接收一个promise对象为参数，并返回一个和接收参数不同的、新的promise对象。</p>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise-and-array">2.7. Promise和数组</h3>
<div class="paragraph">
<p>到目前为止我们已经学习了如何通过 <a href="#promise.then"><code>.then</code></a> 和 <a href="#promise.catch"><code>.catch</code></a> 来注册回调函数，这些回调函数会在promise对象变为 FulFilled 或 Rejected 状态之后被调用。</p>
</div>
<div class="paragraph">
<p>如果只有一个promise对象的话我们可以像前面介绍的那样编写代码就可以了，如果要在多个promise对象都变为FulFilled状态的时候才要进行某种处理话该如何操作呢？</p>
</div>
<div class="paragraph">
<p>我们以当所有XHR（异步处理）全部结束后要进行某操作为例来进行说明。</p>
</div>
<div class="paragraph">
<p>各位读者现在也许有点难以在大脑中描绘出这么一种场景，我们可以先看一下下面使用了普通的回调函数风格的XHR处理代码。</p>
</div>
<div class="sect3">
<h4 id="__9">2.7.1. 通过回调方式来进行多个异步调用</h4>
<div id="multiple-xhr-callback.js" class="listingblock executable">
<div class="title">multiple-xhr-callback.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">getURLCallback</span>(URL, callback) {
    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
    req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
    req.<span class="function">onload</span> = <span class="keyword">function</span> () {
        <span class="keyword">if</span> (req.status === <span class="integer">200</span>) {
            callback(<span class="predefined-constant">null</span>, req.responseText);
        } <span class="keyword">else</span> {
            callback(<span class="keyword">new</span> Error(req.statusText), req.response);
        }
    };
    req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
        callback(<span class="keyword">new</span> Error(req.statusText));
    };
    req.send();
}
<span class="comment">// &lt;1&gt; 对JSON数据进行安全的解析</span>
<span class="keyword">function</span> <span class="function">jsonParse</span>(callback, error, value) {
    <span class="keyword">if</span> (error) {
        callback(error, value);
    } <span class="keyword">else</span> {
        <span class="keyword">try</span> {
            <span class="keyword">var</span> result = JSON.parse(value);
            callback(<span class="predefined-constant">null</span>, result);
        } <span class="keyword">catch</span> (e) {
            callback(e, value);
        }
    }
}
<span class="comment">// &lt;2&gt; 发送XHR请求</span>
<span class="keyword">var</span> request = {
        <span class="function">comment</span>: <span class="keyword">function</span> <span class="function">getComment</span>(callback) {
            <span class="keyword">return</span> getURLCallback(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">'</span></span>, jsonParse.bind(<span class="predefined-constant">null</span>, callback));
        },
        <span class="function">people</span>: <span class="keyword">function</span> <span class="function">getPeople</span>(callback) {
            <span class="keyword">return</span> getURLCallback(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/people.json</span><span class="delimiter">'</span></span>, jsonParse.bind(<span class="predefined-constant">null</span>, callback));
        }
    };
<span class="comment">// &lt;3&gt; 启动多个XHR请求，当所有请求返回时调用callback</span>
<span class="keyword">function</span> <span class="function">allRequest</span>(requests, callback, results) {
    <span class="keyword">if</span> (requests.length === <span class="integer">0</span>) {
        <span class="keyword">return</span> callback(<span class="predefined-constant">null</span>, results);
    }
    <span class="keyword">var</span> req = requests.shift();
    req(<span class="keyword">function</span> (error, value) {
        <span class="keyword">if</span> (error) {
            callback(error, value);
        } <span class="keyword">else</span> {
            results.push(value);
            allRequest(requests, callback, results);
        }
    });
}
<span class="keyword">function</span> <span class="function">main</span>(callback) {
    allRequest([request.comment, request.people], callback, []);
}
<span class="comment">// 运行的例子</span>
main(<span class="keyword">function</span>(error, results){
    <span class="keyword">if</span>(error){
        <span class="keyword">return</span> console.error(error);
    }
    console.log(results);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段回调函数风格的代码有以下几个要点。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>直接使用 <code>JSON.parse</code> 函数的话可能会抛出异常，所以这里使用了一个包装函数 <code>jsonParse</code></p>
</li>
<li>
<p>如果将多个XHR处理进行嵌套调用的话层次会比较深，所以使用了 <code>allRequest</code> 函数并在其中对request进行调用。</p>
</li>
<li>
<p>回调函数采用了 <code>callback(error,value)</code> 这种写法，第一个参数表示错误信息，第二个参数为返回值</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在使用 <code>jsonParse</code> 函数的时候我们使用了 <code>bind</code> 进行绑定，通过使用这种偏函数（Partial Function）的方式就可以减少匿名函数的使用。（如果在函数回调风格的代码能很好的做到函数分离的话，也能减少匿名函数的数量）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">jsonParse.bind(<span class="predefined-constant">null</span>, callback);
<span class="comment">// 可以认为这种写法能转换为以下的写法</span>
<span class="keyword">function</span> <span class="function">bindJSONParse</span>(error, value){
    jsonParse(callback, error, value);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这段回调风格的代码中，我们也能发现如下一些问题。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>需要显示进行异常处理</p>
</li>
<li>
<p>为了不让嵌套层次太深，需要一个对request进行处理的函数</p>
</li>
<li>
<p>到处都是回调函数</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面我们再来看看如何使用 <code>Promise#then</code> 来完成同样的工作。</p>
</div>
</div>
<div class="sect3">
<h4 id="__promise_then">2.7.2. 使用Promise#then同时处理多个异步请求</h4>
<div class="paragraph">
<p>需要事先说明的是 <code>Promise.all</code> 比较适合这种应用场景的需求，因此我们故意采用了大量 <code>.then</code> 的晦涩的写法。</p>
</div>
<div class="paragraph">
<p>使用了<a href="#promise.then"><code>.then</code></a> 的话，也并不是说能和回调风格完全一致，大概重写后代码如下所示。</p>
</div>
<div id="multiple-xhr.js" class="listingblock executable">
<div class="title">multiple-xhr.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">getURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onload</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.status === <span class="integer">200</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
<span class="keyword">var</span> request = {
        <span class="function">comment</span>: <span class="keyword">function</span> <span class="function">getComment</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        },
        <span class="function">people</span>: <span class="keyword">function</span> <span class="function">getPeople</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/people.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        }
    };
<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="keyword">function</span> <span class="function">recordValue</span>(results, value) {
        results.push(value);
        <span class="keyword">return</span> results;
    }
    <span class="comment">// [] 用来保存初始化的值</span>
    <span class="keyword">var</span> pushValue = recordValue.bind(<span class="predefined-constant">null</span>, []);
    <span class="keyword">return</span> request.comment().then(pushValue).then(request.people).then(pushValue);
}
<span class="comment">// 运行的例子</span>
main().then(<span class="keyword">function</span> (value) {
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>将上述代码和<a href="#multiple-xhr-callback.js">回调函数风格</a>相比，我们可以得到如下结论。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>可以直接使用 <code>JSON.parse</code> 函数</p>
</li>
<li>
<p>函数 <code>main()</code> 返回promise对象</p>
</li>
<li>
<p>错误处理的地方直接对返回的promise对象进行处理</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>向前面我们说的那样，main的 <code>then</code> 部分有点晦涩难懂。</p>
</div>
<div class="paragraph">
<p>为了应对这种需要对多个异步调用进行统一处理的场景，Promise准备了 <code>Promise.all</code> 和 <code>Promise.race</code> 这两个静态方法。</p>
</div>
<div class="paragraph">
<p>在下面的小节中我们将对这两个函数进行说明。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise-all">2.8. Promise.all</h3>
<div class="paragraph">
<p><a href="#Promise.all"><code>Promise.all</code></a> 接收一个 promise对象的数组作为参数，当这个数组里的所有promise对象全部变为resolve或reject状态的时候，它才会去调用 <code>.then</code> 方法。</p>
</div>
<div class="paragraph">
<p>前面我们看到的批量获得若干XHR的请求结果的例子，使用 <a href="#Promise.all"><code>Promise.all</code></a> 的话代码会非常简单。</p>
</div>
<div class="paragraph">
<p>之前例子中的 <code>getURL</code> 返回了一个promise对象，它封装了XHR通信的实现。
向 <code>Promise.all</code> 传递一个由封装了XHR通信的promise对象数组的话，则只有在全部的XHR通信完成之后（变为FulFilled或Rejected状态）之后，才会调用 <code>.then</code> 方法。</p>
</div>
<div id="promise-all-xhr.js" class="listingblock executable">
<div class="title">promise-all-xhr.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">getURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onload</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.status === <span class="integer">200</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
<span class="keyword">var</span> request = {
        <span class="function">comment</span>: <span class="keyword">function</span> <span class="function">getComment</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        },
        <span class="function">people</span>: <span class="keyword">function</span> <span class="function">getPeople</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/people.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        }
    };
<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="keyword">return</span> Promise.all([request.comment(), request.people()]);
}
<span class="comment">// 运行示例</span>
main().then(<span class="keyword">function</span> (value) {
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.log(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个例子的执行方法和 <a href="#xhr-promise.js">前面的例子</a> 一样。
不过<a href="#Promise.all"><code>Promise.all</code></a> 在以下几点和之前的例子有所不同。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>main中的处理流程显得非常清晰</p>
</li>
<li>
<p>Promise.all 接收 promise对象组成的数组作为参数</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Promise.all([request.comment(), request.people()]);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的代码中，<code>request.comment()</code> 和 <code>request.people()</code> 会同时开始执行，而且每个promise的结果（resolve或reject时传递的参数值），和传递给 <a href="#Promise.all"><code>Promise.all</code></a> 的promise数组的顺序是一致的。</p>
</div>
<div class="paragraph">
<p>也就是说，这时候 <code>.then</code> 得到的promise数组的执行结果的顺序是固定的，即 [comment, people]。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">main().then(<span class="keyword">function</span> (results) {
    console.log(results); <span class="comment">// 按照[comment, people]的顺序</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果像下面那样使用一个计时器来计算一下程序执行时间的话，那么就可以非常清楚的知道传递给 <a href="#Promise.all"><code>Promise.all</code></a> 的promise数组是同时开始执行的。</p>
</div>
<div id="promise-all-timer.js" class="listingblock executable">
<div class="title">promise-all-timer.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="comment">// `delay`毫秒后执行resolve</span>
<span class="keyword">function</span> <span class="function">timerPromisefy</span>(delay) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(<span class="keyword">function</span> () {
            resolve(delay);
        }, delay);
    });
}
<span class="keyword">var</span> startDate = Date.now();
<span class="comment">// 所有promise变为resolve后程序退出</span>
Promise.all([
    timerPromisefy(<span class="integer">1</span>),
    timerPromisefy(<span class="integer">32</span>),
    timerPromisefy(<span class="integer">64</span>),
    timerPromisefy(<span class="integer">128</span>)
]).then(<span class="keyword">function</span> (values) {
    console.log(Date.now() - startDate + <span class="string"><span class="delimiter">'</span><span class="content">ms</span><span class="delimiter">'</span></span>);
    <span class="comment">// 約128ms</span>
    console.log(values);    <span class="comment">// [1,32,64,128]</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>timerPromisefy</code> 会每隔一定时间（通过参数指定）之后，返回一个promise对象，状态为FulFilled，其状态值为传给 <code>timerPromisefy</code> 的参数。</p>
</div>
<div class="paragraph">
<p>而传给 <code>Promise.all</code> 的则是由上述promise组成的数组。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promises = [
    timerPromisefy(<span class="integer">1</span>),
    timerPromisefy(<span class="integer">32</span>),
    timerPromisefy(<span class="integer">64</span>),
    timerPromisefy(<span class="integer">128</span>)
];</code></pre>
</div>
</div>
<div class="paragraph">
<p>这时候，每隔1, 32, 64, 128 ms都会有一个promise发生 <code>resolve</code> 行为。</p>
</div>
<div class="paragraph">
<p>也就是说，这个promise对象数组中所有promise都变为resolve状态的话，至少需要128ms。实际我们计算一下<a href="#Promise.all"><code>Promise.all</code></a> 的执行时间的话，它确实是消耗了128ms的时间。</p>
</div>
<div class="paragraph">
<p>从上述结果可以看出，传递给 <a href="#Promise.all"><code>Promise.all</code></a> 的promise并不是一个个的顺序执行的，而是同时开始、并行执行的。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果这些promise全部串行处理的话，那么需要
等待1ms &#8594; 等待32ms &#8594; 等待64ms &#8594; 等待128ms ，全部执行完毕需要225ms的时间。</p>
</div>
<div class="paragraph">
<p>要想了解更多关于如何使用Promise进行串行处理的内容，可以参考第4章的<a href="#promise-sequence">Promise中的串行处理</a>中的介绍。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise-race">2.9. Promise.race</h3>
<div class="paragraph">
<p>接着我们来看看和 <a href="#Promise.all"><code>Promise.all</code></a> 类似的对多个promise对象进行处理的 <a href="#Promise.race"><code>Promise.race</code></a> 方法。</p>
</div>
<div class="paragraph">
<p>它的使用方法和Promise.all一样，接收一个promise对象数组为参数。</p>
</div>
<div class="paragraph">
<p><code>Promise.all</code> 在接收到的所有的对象promise都变为 FulFilled 或者 Rejected 状态之后才会继续进行后面的处理，
与之相对的是 <code>Promise.race</code> 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。</p>
</div>
<div class="paragraph">
<p>像Promise.all时的例子一样，我们来看一个带计时器的 <code>Promise.race</code> 的使用例子。</p>
</div>
<div id="promise-race-timer.js" class="listingblock executable">
<div class="title">promise-race-timer.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="comment">// `delay`毫秒后执行resolve</span>
<span class="keyword">function</span> <span class="function">timerPromisefy</span>(delay) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(<span class="keyword">function</span> () {
            resolve(delay);
        }, delay);
    });
}
<span class="comment">// 任何一个promise变为resolve或reject 的话程序就停止运行</span>
Promise.race([
    timerPromisefy(<span class="integer">1</span>),
    timerPromisefy(<span class="integer">32</span>),
    timerPromisefy(<span class="integer">64</span>),
    timerPromisefy(<span class="integer">128</span>)
]).then(<span class="keyword">function</span> (value) {
    console.log(value);    <span class="comment">// =&gt; 1</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码创建了4个promise对象，这些promise对象会分别在1ms，32ms，64ms和128ms后变为确定状态，即FulFilled，并且在第一个变为确定状态的1ms后， <code>.then</code> 注册的回调函数就会被调用，这时候确定状态的promise对象会调用 <code>resolve(1)</code> 因此传递给 <code>value</code> 的值也是1，控制台上会打印出<code>1</code>来。</p>
</div>
<div class="paragraph">
<p>下面我们再来看看在第一个promise对象变为确定（FulFilled）状态后，它之后的promise对象是否还在继续运行。</p>
</div>
<div id="promise-race-other.js" class="listingblock executable">
<div class="title">promise-race-other.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> winnerPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(<span class="keyword">function</span> () {
            console.log(<span class="string"><span class="delimiter">'</span><span class="content">this is winner</span><span class="delimiter">'</span></span>);
            resolve(<span class="string"><span class="delimiter">'</span><span class="content">this is winner</span><span class="delimiter">'</span></span>);
        }, <span class="integer">4</span>);
    });
<span class="keyword">var</span> loserPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(<span class="keyword">function</span> () {
            console.log(<span class="string"><span class="delimiter">'</span><span class="content">this is loser</span><span class="delimiter">'</span></span>);
            resolve(<span class="string"><span class="delimiter">'</span><span class="content">this is loser</span><span class="delimiter">'</span></span>);
        }, <span class="integer">1000</span>);
    });
<span class="comment">// 第一个promise变为resolve后程序停止</span>
Promise.race([winnerPromise, loserPromise]).then(<span class="keyword">function</span> (value) {
    console.log(value);    <span class="comment">// =&gt; 'this is winner'</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们在前面代码的基础上增加了 <code>console.log</code> 用来输出调试信息。</p>
</div>
<div class="paragraph">
<p>执行上面代码的话，我们会看到 winnter和loser promise对象的 <code>setTimeout</code> 方法都会执行完毕， <code>console.log</code> 也会分别输出它们的信息。</p>
</div>
<div class="paragraph">
<p>也就是说， <a href="#Promise.race"><code>Promise.race</code></a> 在第一个promise对象变为Fulfilled之后，并不会取消其他promise对象的执行。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
在 <a href="#es6-promises">ES6 Promises</a> 规范中，也没有取消（中断）promise对象执行的概念，我们必须要确保promise最终进入resolve or reject状态之一。也就是说Promise并不适用于 <a href="#promise-states">状态</a> 可能会固定不变的处理。也有一些类库提供了对promise进行取消的操作。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="then-or-catch">2.10. then or catch?</h3>
<div class="paragraph">
<p>在 <a href="#catch-as-alias">上一章</a> 里，我们说过 <a href="#promise.catch"><code>.catch</code></a> 也可以理解为 <code>promise.then(undefined, onRejected)</code> 。</p>
</div>
<div class="paragraph">
<p>在本书里我们还是会将 <a href="#promise.catch"><code>.catch</code></a> 和 <a href="#promise.then"><code>.then</code></a> 分开使用来进行错误处理的。</p>
</div>
<div class="paragraph">
<p>此外我们也会学习一下，在 <code>.then</code> 里同时指定处理对错误进行处理的函数相比，和使用 <code>catch</code> 又有什么异同。</p>
</div>
<div class="sect3">
<h4 id="__onrejected">2.10.1. 不能进行错误处理的onRejected</h4>
<div class="paragraph">
<p>我们看看下面的这段代码。</p>
</div>
<div id="then-throw-error.js" class="listingblock executable">
<div class="title">then-throw-error.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">throwError</span>(value) {
    <span class="comment">// 抛出异常</span>
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(value);
}
<span class="comment">// &lt;1&gt; onRejected不会被调用</span>
<span class="keyword">function</span> <span class="function">badMain</span>(onRejected) {
    <span class="keyword">return</span> Promise.resolve(<span class="integer">42</span>).then(throwError, onRejected);
}
<span class="comment">// &lt;2&gt; 有异常发生时onRejected会被调用</span>
<span class="keyword">function</span> <span class="function">goodMain</span>(onRejected) {
    <span class="keyword">return</span> Promise.resolve(<span class="integer">42</span>).then(throwError).<span class="keyword">catch</span>(onRejected);
}
<span class="comment">// 运行示例</span>
badMain(<span class="keyword">function</span>(){
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">BAD</span><span class="delimiter">&quot;</span></span>);
});
goodMain(<span class="keyword">function</span>(){
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">GOOD</span><span class="delimiter">&quot;</span></span>);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的代码中， <code>badMain</code> 是一个不太好的实现方式（但也不是说它有多坏）， <code>goodMain</code> 则是一个能非常好的进行错误处理的版本。</p>
</div>
<div class="paragraph">
<p>为什么说 <code>badMain</code> 不好呢？，因为虽然我们在 <code>.then</code> 的第二个参数中指定了用来错误处理的函数，但实际上它却不能捕获第一个参数 <code>onFulfilled</code> 指定的函数（本例为 <code>throwError</code> ）里面出现的错误。</p>
</div>
<div class="paragraph">
<p>也就是说，这时候即使 <code>throwError</code> 抛出了异常，<code>onRejected</code> 指定的函数也不会被调用（即不会输出"BAD"字样）。</p>
</div>
<div class="paragraph">
<p>与此相对的是， <code>goodMain</code> 的代码则遵循了 <code>throwError</code>&#8594;<code>onRejected</code> 的调用流程。
这时候 <code>throwError</code> 中出现异常的话，在会被方法链中的下一个方法，即 <code>.catch</code> 所捕获，进行相应的错误处理。</p>
</div>
<div class="paragraph">
<p><code>.then</code> 方法中的onRejected参数所指定的回调函数，实际上针对的是其promise对象或者之前的promise对象，而不是针对
<code>.then</code> 方法里面指定的第一个参数，即onFulfilled所指向的对象，这也是 <code>then</code> 和 <code>catch</code> 表现不同的原因。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>.then</code> 和 <code>.catch</code> 都会创建并返回一个 <strong>新的</strong> promise对象。
Promise实际上每次在方法链中增加一次处理的时候所操作的都不是完全相同的promise对象。</p>
</div>
</td>
</tr>
</table>
</div>
<div id="then-catch-flow" class="imageblock">
<div class="content">
<img src="Ch2_HowToWrite/img/then_catch.png" alt="Then Catch flow">
</div>
<div class="title">Figure 6. Then Catch flow</div>
</div>
<div class="paragraph">
<p>这种情况下 <code>then</code> 是针对 <code>Promise.resolve(42)</code> 的处理，在<code>onFulfilled</code> 中发生异常，在同一个 <code>then</code> 方法中指定的 <code>onRejected</code> 也不能捕获该异常。</p>
</div>
<div class="paragraph">
<p>在这个 <code>then</code> 中发生的异常，只有在该方法链后面出现的 <code>catch</code> 方法才能捕获。</p>
</div>
<div class="paragraph">
<p>当然，由于 <code>.catch</code> 方法是 <code>.then</code> 的别名，我们使用 <code>.then</code> 也能完成同样的工作。只不过使用 <code>.catch</code> 的话意图更明确，更容易理解。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Promise.resolve(<span class="integer">42</span>).then(throwError).then(<span class="predefined-constant">null</span>, onRejected);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__10">2.10.2. 总结</h4>
<div class="paragraph">
<p>这里我们又学习到了如下一些内容。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用<code>promise.then(onFulfilled, onRejected)</code> 的话</p>
<div class="ulist">
<ul>
<li>
<p>在 <code>onFulfilled</code> 中发生异常的话，在 <code>onRejected</code> 中是捕获不到这个异常的。</p>
</li>
</ul>
</div>
</li>
<li>
<p>在 <code>promise.then(onFulfilled).catch(onRejected)</code> 的情况下</p>
<div class="ulist">
<ul>
<li>
<p><code>then</code> 中产生的异常能在 <code>.catch</code> 中捕获</p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#promise.then"><code>.then</code></a> 和 <a href="#promise.catch"><code>.catch</code></a> 在本质上是没有区别的</p>
<div class="ulist">
<ul>
<li>
<p>需要分场合使用。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>我们需要注意如果代码类似 <code>badMain</code> 那样的话，就可能出现程序不会按预期运行的情况，从而不能正确的进行错误处理。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter3-promise-testing">3. Chapter.3 - Promise测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这章我们学习如果编写Promise 的测试代码</p>
</div>
<div class="sect2">
<h3 id="basic-tests">3.1. 基本测试</h3>
<div class="paragraph">
<p>关于<a href="#es6-promises">ES6 Promises</a>的语法我们已经学了一些，
我想大家应该也能够在实际项目中编写Promise 的Demo代码了吧。</p>
</div>
<div class="paragraph">
<p>这时，接下来你可能要苦恼该如何编写Promise 的测试代码了。</p>
</div>
<div class="paragraph">
<p>那么让我们先来学习下如何使用 <a href="http://mochajs.org/">Mocha</a>来对Promise 进行基本的测试吧。</p>
</div>
<div class="paragraph">
<p>先声明一下，这章中涉及的测试代码都是运行在Node.js环境下的。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
本书中出现的示例代码也都有相应的测试代码。
测试代码可以参考 <a href="https://github.com/azu/promises-book">azu/promises-book</a> 。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_mocha">3.1.1. Mocha</h4>
<div class="paragraph">
<p>Mocha是Node.js下的测试框架工具,在这里，我们并不打算对 <a href="http://mochajs.org/">Mocha</a>本身进行详细讲解。对
<a href="http://mochajs.org/">Mocha</a>感兴趣的读者可以自行学习。</p>
</div>
<div class="paragraph">
<p>Mocha可以自由选择BDD、TDD、exports中的任意风格，测试中用到的Assert 方法也同样可以跟任何其他类库组合使用。
也就是说，Mocha本身只提供执行测试时的框架，而其他部分则由使用者自己选择。</p>
</div>
<div class="paragraph">
<p>这里我们选择使用Mocha，主要基于下面3点理由。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它是非常著名的测试框架</p>
</li>
<li>
<p>支持基于Node.js 和浏览器的测试</p>
</li>
<li>
<p>支持"Promise测试"</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最后至于为什么说 <em>支持"Promise测试"</em> ，这个我们在后面再讲。</p>
</div>
<div class="paragraph">
<p>要想在本章中使用Mocha，我们需要先通过npm来安装Mocha。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="console language-console">$ npm install -g mocha</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，Assert库我们使用的是Node.js自带的<code>assert</code>模块，所以不需要额外安装。</p>
</div>
<div class="paragraph">
<p>首先，让我们试着编写一个对传统回调风格的异步函数进行测试的代码。</p>
</div>
</div>
<div class="sect3">
<h4 id="__11">3.1.2. 回调函数风格的测试</h4>
<div class="paragraph">
<p>如果想使用回调函数风格来对一个异步处理进行测试，使用Mocha的话代码如下所示。</p>
</div>
<div class="listingblock">
<div class="title">basic-test.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> assert = require(<span class="string"><span class="delimiter">'</span><span class="content">power-assert</span><span class="delimiter">'</span></span>);
describe(<span class="string"><span class="delimiter">'</span><span class="content">Basic Test</span><span class="delimiter">'</span></span>, <span class="keyword">function</span> () {
    context(<span class="string"><span class="delimiter">'</span><span class="content">When Callback(high-order function)</span><span class="delimiter">'</span></span>, <span class="keyword">function</span> () {
        it(<span class="string"><span class="delimiter">'</span><span class="content">should use `done` for test</span><span class="delimiter">'</span></span>, <span class="keyword">function</span> (done) {
            setTimeout(<span class="keyword">function</span> () {
                assert(<span class="predefined-constant">true</span>);
                done();
            }, <span class="integer">0</span>);
        });
    });
    context(<span class="string"><span class="delimiter">'</span><span class="content">When promise object</span><span class="delimiter">'</span></span>, <span class="keyword">function</span> () {
        it(<span class="string"><span class="delimiter">'</span><span class="content">should use `done` for test?</span><span class="delimiter">'</span></span>, <span class="keyword">function</span> (done) {
            <span class="keyword">var</span> promise = Promise.resolve(<span class="integer">1</span>);
            <span class="comment">// このテストコードはある欠陥があります</span>
            promise.then(<span class="keyword">function</span> (value) {
                assert(value === <span class="integer">1</span>);
                done();
            });
        });
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>将这段代码保存为 <code>basic-test.js</code>，之后就可以使用刚才安装的Mocha的命令行工具进行测试了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="sh language-sh">$ mocha basic-test.js</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mocha的 <code>it</code> 方法指定了 <code>done</code> 参数，在 <code>done()</code> 函数被执行之前，
该测试一直处于等待状态，这样就可以对异步处理进行测试。</p>
</div>
<div class="paragraph">
<p>Mocha中的异步测试，将会按照下面的步骤执行。</p>
</div>
<div id="callback-style-test" class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should use `done` for test</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> (done) {
    <i class="conum" data-value="1"></i><b>(1)</b>
    setTimeout(<span class="keyword">function</span> () {
        assert(<span class="predefined-constant">true</span>);
        done();<i class="conum" data-value="2"></i><b>(2)</b>
    }, <span class="integer">0</span>);
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>回调式的异步处理</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>调用<code>done</code> 后测试结束</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这也是一种非常常见的实现方式。</p>
</div>
</div>
<div class="sect3">
<h4 id="done-promise-test">3.1.3. 使用<code>done</code> 的Promise测试</h4>
<div class="paragraph">
<p>接下来，让我们看看如何使用 <code>done</code> 来进行Promise测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should use `done` for test?</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> (done) {
    <span class="keyword">var</span> promise = Promise.resolve(<span class="integer">42</span>);<i class="conum" data-value="1"></i><b>(1)</b>
    promise.then(<span class="keyword">function</span> (value) {
        assert(value === <span class="integer">42</span>);
        done();<i class="conum" data-value="2"></i><b>(2)</b>
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建名为<code>Fulfilled</code> 的promise对象</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>调用<code>done</code> 后测试结束</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="#Promise.resolve"><code>Promise.resolve</code></a> 用来返回promise对象，
返回的promise对象状态为FulFilled。
最后，通过 <code>.then</code> 设置的回调函数也会被调用。</p>
</div>
<div class="paragraph">
<p>像<a href="#promise-is-always-async">专栏: Promise只能进行异步操作？</a> 中已经提到的那样，
promise对象的调用总是异步进行的，所以测试也同样需要以异步调用的方式来编写。</p>
</div>
<div class="paragraph">
<p>但是，在前面的测试代码中，在<code>assert</code> 失败的情况下就会出现问题。</p>
</div>
<div id="promise-assert-fail" class="listingblock">
<div class="title">对异常promise测试</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should use `done` for test?</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> (done) {
    <span class="keyword">var</span> promise = Promise.resolve();
    promise.then(<span class="keyword">function</span> (value) {
        assert(<span class="predefined-constant">false</span>);<span class="comment">// =&gt; throw AssertionError</span>
        done();
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此次测试中 <code>assert</code> 失败了，所以你可能认为应该抛出“测试失败”的错误，
而实际情况却是测试并不会结束，直到超时。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch3_Testing/img/promise-test-timeout.png" alt="promise test timeout">
</div>
<div class="title">Figure 7. 由于测试不会结束，所以直到发生超时时间未知，一直会处于挂起状态。</div>
</div>
<div class="paragraph">
<p>通常情况下，<code>assert</code> 失败的时候，会throw一个error，
测试框架会捕获该error，来判断测试失败。</p>
</div>
<div class="paragraph">
<p>但是，Promise的情况下 <code>.then</code> 绑定的函数执行时发生的error
会被Promise捕获，而测试框架则对此error将会一无所知。</p>
</div>
<div class="paragraph">
<p>我们来改善一下<a href="#promise-assert-fail"><code>assert</code> 失败的promise测试</a>，
让它能正确处理 <code>assert</code> 失败时的测试结果。</p>
</div>
<div id="promise-assert-fail-fixed" class="listingblock">
<div class="title">测试正常失败的示例</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should use `done` for test?</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> (done) {
    <span class="keyword">var</span> promise = Promise.resolve();
    promise.then(<span class="keyword">function</span> (value) {
        assert(<span class="predefined-constant">false</span>);
    }).then(done, done);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面测试正常失败的示例中，为了确保 <code>done</code> 一定会被调用，
我们在最后添加了 <code>.then(done, done);</code> 语句。</p>
</div>
<div class="paragraph">
<p><code>assert</code> 测试通过（成功）时会调用 <code>done()</code> ，而 <code>assert</code> 失败时则调用 <code>done(error)</code> 。</p>
</div>
<div class="paragraph">
<p>这样，我们就编写出了和 <a href="#callback-style-test">回调函数风格的测试</a> 相同的Promise测试。</p>
</div>
<div class="paragraph">
<p>但是，为了处理 <code>assert</code> 失败的情况，我们需要额外添加 <code>.then(done, done);</code> 的代码。
这就要求我们在编写Promise测试时要格外小心，忘了加上上面语句的话，很可能就会写出一个永远不会返回直到超时的测试代码。</p>
</div>
<div class="paragraph">
<p>在下一节，让我们接着学习一下最初提到的使用Mocha理由中的支持"Promises测试"究竟是一种什么机制。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mocha-promise">3.2. Mocha对Promise的支持</h3>
<div class="paragraph">
<p>在这里，我们将会学习什么是Mocha支持的“对Promise测试”。</p>
</div>
<div class="paragraph">
<p>官方网站 <a href="http://mochajs.org/#asynchronous-code">Asynchronous code</a> 也记载了关于Promise测试的概要。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Alternately, instead of using the done() callback, you can return a promise. This is useful if the APIs you are testing return promises instead of taking callbacks:</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>这段话的意思是，在对Promise进行测试的时候，不使用 <code>done()</code> 这样的回调风格的代码编写方式，而是返回一个promise对象。</p>
</div>
<div class="paragraph">
<p>那么实际上代码将会是什么样的呢？这里我们来看个具体的例子应该容易理解了。</p>
</div>
<div id="mocha-promise-test.js" class="listingblock">
<div class="title">mocha-promise-test.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> assert = require(<span class="string"><span class="delimiter">'</span><span class="content">power-assert</span><span class="delimiter">'</span></span>);
describe(<span class="string"><span class="delimiter">'</span><span class="content">Promise Test</span><span class="delimiter">'</span></span>, <span class="keyword">function</span> () {
    it(<span class="string"><span class="delimiter">'</span><span class="content">should return a promise object</span><span class="delimiter">'</span></span>, <span class="keyword">function</span> () {
        <span class="keyword">var</span> promise = Promise.resolve(<span class="integer">1</span>);
        <span class="keyword">return</span> promise.then(<span class="keyword">function</span> (value) {
            assert(value === <span class="integer">1</span>);
        });
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码将前面 <a href="#promise-assert-fail-fixed">前面使用 <code>done</code> 的例子</a> 按照Mocha的Promise测试方式进行了重写。</p>
</div>
<div class="paragraph">
<p>修改的地方主要在以下两点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>删除了 <code>done</code></p>
</li>
<li>
<p>返回结果为promise对象</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>采用这种写法的话，当 <code>assert</code> 失败的时候，测试本身自然也会失败。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should be fail</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
    <span class="keyword">return</span> Promise.resolve().then(<span class="keyword">function</span> () {
        assert(<span class="predefined-constant">false</span>);<span class="comment">// =&gt; 测试失败</span>
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>采用这种方法，就能从根本上省略诸如 <code>.then(done, done);</code> 这样本质上跟测试逻辑并无直接关系的代码。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="http://efcl.info/2014/0314/res3708/">Mocha已经支持对Promises的测试 | Web scratch</a> 这篇（日语）文章里也提到了关于Mocha对Promise测试的支持。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="__12">3.2.1. 意料之外（失败的）的测试结果</h4>
<div class="paragraph">
<p>因为Mocha提供了对Promise的测试，所以我们会认为按照Mocha的规则来写会比较好。
但是这种代码可能会带来意想不到的异常情况的发生。</p>
</div>
<div class="paragraph">
<p>比如对下面的<code>mayBeRejected()</code> 函数的测试代码，该函数返回一个当满足某一条件就变为Rejected的promise对象。</p>
</div>
<div id="mocha-rejected-promise-test" class="listingblock">
<div class="title">想对Error Object进行测试</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">mayBeRejected</span>(){ <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">return</span> Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">woo</span><span class="delimiter">&quot;</span></span>));
}
it(<span class="string"><span class="delimiter">&quot;</span><span class="content">is bad pattern</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
    <span class="keyword">return</span> mayBeRejected().<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
        assert(error.message === <span class="string"><span class="delimiter">&quot;</span><span class="content">woo</span><span class="delimiter">&quot;</span></span>);
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这个函数用来对返回的promise对象进行测试</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这个测试的目的包括以下两点：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>mayBeRejected()</code> 返回的promise对象如果变为FulFilled状态的话</dt>
<dd>
<p>测试将会失败</p>
</dd>
<dt class="hdlist1"><code>mayBeRejected()</code> 返回的promise对象如果变为Rejected状态的话</dt>
<dd>
<p>在 <code>assert</code> 中对Error对象进行检查</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>上面的测试代码，当promise对象变为Rejected的时候，会调用在 <code>onRejected</code> 中注册的函数，从而没有走正promise的处理常流程，测试会成功。</p>
</div>
<div class="paragraph">
<p>这段测试代码的问题在于当<code>mayBeRejected()</code> 返回的是一个
<strong>为FulFilled状态的promise对象时</strong>，测试会一直成功。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">mayBeRejected</span>(){ <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">return</span> Promise.resolve();
}
it(<span class="string"><span class="delimiter">&quot;</span><span class="content">is bad pattern</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
    <span class="keyword">return</span> mayBeRejected().<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
        assert(error.message === <span class="string"><span class="delimiter">&quot;</span><span class="content">woo</span><span class="delimiter">&quot;</span></span>);
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>返回的promise对象会变为FulFilled</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在这种情况下，由于在 <code>catch</code> 中注册的 <code>onRejected</code> 函数并不会被调用，因此
<code>assert</code> 也不会被执行，测试会一直通过（passed，成功）。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，我们可以在 <code>.catch</code> 的前面加入一个 <code>.then</code> 调用，可以理解为如果调用了
<code>.then</code> 的话，那么测试就需要失败。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">failTest</span>() { <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">Expected promise to be rejected but it was fulfilled</span><span class="delimiter">&quot;</span></span>);
}
<span class="keyword">function</span> <span class="function">mayBeRejected</span>(){
    <span class="keyword">return</span> Promise.resolve();
}
it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should bad pattern</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
    <span class="keyword">return</span> mayBeRejected().then(failTest).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
        assert.deepEqual(error.message === <span class="string"><span class="delimiter">&quot;</span><span class="content">woo</span><span class="delimiter">&quot;</span></span>);
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>通过throw来使测试失败</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>但是，这种写法会像在前面 <a href="#then-or-catch">then or catch?</a> 中已经介绍的一样，
<code>failTest</code> 抛出的异常会被 <code>catch</code> 捕获。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch2_HowToWrite/img/then_catch.png" alt="Then Catch flow">
</div>
<div class="title">Figure 8. Then Catch flow</div>
</div>
<div class="paragraph">
<p>程序的执行流程为 <code>then</code> &#8594; <code>catch</code>，传递给 <code>catch</code> 的Error对象为<code>AssertionError</code>类型 ，
这并不是我们想要的东西。</p>
</div>
<div class="paragraph">
<p>也就是说，我们希望测试<strong>只能</strong>通过状态会变为onRejected的promise对象，
如果promise对象状态为onFulfilled状态的话，那么该测试就会一直通过。</p>
</div>
</div>
<div class="sect3">
<h4 id="__13">3.2.2. 明确两种状态，改善测试中的意外（异常）状况</h4>
<div class="paragraph">
<p>在编写 <a href="#mocha-rejected-promise-test">上面对Error对象进行测试的例子</a> 时，
怎么才能剔除那些会意外通过测试的情况呢？</p>
</div>
<div class="paragraph">
<p>最简单的方式就是像下面这样，在测试代码中判断在各种promise对象的状态下，应进行如何的操作。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">变为FulFilled状态的时候</dt>
<dd>
<p>测试会预期失败</p>
</dd>
<dt class="hdlist1">变为Rejected状态的时候</dt>
<dd>
<p>使用 <code>assert</code> 进行测试</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>也就是说，我们需要在测试代码中明确指定在Fulfilled和Rejected这两种状态下，都需进行什么样的处理。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">mayBeRejected</span>() {
    <span class="keyword">return</span> Promise.resolve();
}
it(<span class="string"><span class="delimiter">&quot;</span><span class="content">catch -&gt; then</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
    <span class="comment">// 变为FulFilled的时候测试失败</span>
    <span class="keyword">return</span> mayBeRejected().then(failTest, <span class="keyword">function</span> (error) {
        assert(error.message === <span class="string"><span class="delimiter">&quot;</span><span class="content">woo</span><span class="delimiter">&quot;</span></span>);
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>像这样的话，就能在promise变为FulFilled的时候编写出失败用的测试代码了。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch3_Testing/img/promise-test.png" alt="Promise onRejected test">
</div>
<div class="title">Figure 9. Promise onRejected test</div>
</div>
<div class="paragraph">
<p>在 <a href="#then-or-catch">then or catch?</a> 中我们已经讲过，为了避免遗漏对错误的处理，
与使用 <code>.then(onFulfilled, onRejected)</code> 这样带有二个参数的调用形式相比，
我们更推荐使用 <code>then</code> &#8594; <code>catch</code> 这样的处理方式。</p>
</div>
<div class="paragraph">
<p>但是在编写测试代码的时候，Promise强大的错误处理机制反而成了限制我们的障碍。
因此我们不得已采取了 <code>.then(failTest, onRejected)</code> 这种写法，明确指定promise在各种状态下进行何种的处理。</p>
</div>
</div>
<div class="sect3">
<h4 id="__14">3.2.3. 总结</h4>
<div class="paragraph">
<p>在本小节中我们对在使用Mocha进行Promise测试时可能出现的一些意外情况进行了介绍。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>普通的代码采用 <code>then</code> &#8594; <code>catch</code> 的流程的话比较容易理解</p>
<div class="ulist">
<ul>
<li>
<p>这是为了错误处理的方便。请参考 <a href="#then-or-catch">then or catch?</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>将测试代码集中到 <code>then</code> 中处理</p>
<div class="ulist">
<ul>
<li>
<p>为了能将AssertionError对象传递到测试框架中。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过使用 <code>.then(onFulfilled, onRejected)</code> 这种形式的写法，
我们可以明确指定promise对象在变为 Fulfilled或Rejected时如何进行处理。</p>
</div>
<div class="paragraph">
<p>但是，由于需要显示的指定 Rejected时的测试处理，
像下面这样的代码看起来总是有一些让人感到不太直观的感觉。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">promise.then(failTest, <span class="keyword">function</span>(error){
    <span class="comment">// 使用assert对error进行测试</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在下一小节，我们会介绍如何编写helper函数以方便编写Promise的测试代码，
以及怎样去编写更容易理解的测试代码。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="controllable-tests">3.3. 编写可控测试（controllable tests）</h3>
<div class="paragraph">
<p>在继续进行说明之前，我们先来定义一下什么是可控测试。在这里我们对可控测试的定义如下。</p>
</div>
<div class="paragraph">
<p>待测试的promise对象</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果编写预期为Fulfilled状态的测试的话</p>
<div class="ulist">
<ul>
<li>
<p>Rejected的时候要 <strong>Fail</strong></p>
</li>
<li>
<p>assertion 的结果不一致的时候要 <strong>Fail</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>如果预期为Rejected状态的话</p>
<div class="ulist">
<ul>
<li>
<p>结果为Fulfilled 测试为 <strong>Fail</strong></p>
</li>
<li>
<p>assertion 的结果不一致的时候要 <strong>Fail</strong></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果一个测试能网罗上面的用例（Fail）项，那么我们就称其为可控测试。</p>
</div>
<div class="paragraph">
<p>也就是说，一个测试用例应该包括下面的测试内容。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>结果满足 Fulfilled or Rejected 之一</p>
</li>
<li>
<p>对传递给assertion的值进行检查</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在前面使用了 <code>.then</code> 的代码就是一个期望结果为 Rejected 的测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">promise.then(failTest, <span class="keyword">function</span>(error){
    <span class="comment">// 通过assert验证error对象</span>
    assert(error <span class="keyword">instanceof</span> Error);
});</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="__15">3.3.1. 必须明确指定转换后的状态</h4>
<div class="paragraph">
<p>为了编写有效的测试代码， 我们需要明确指定 <a href="#promise-states">promise的状态</a> 为
Fulfilled or Rejected 的两者之一。</p>
</div>
<div class="paragraph">
<p>但是由于 <code>.then</code> 的话在调用的时候可以省略参数，有时候可能会忘记加入使测试失败的条件。</p>
</div>
<div class="paragraph">
<p>因此，我们可以定义一个helper函数，用来明确定义promise期望的状态。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>笔者（原著者）创建了一个类库 <a href="https://github.com/azu/promise-test-helper">azu/promise-test-helper</a> 以方便对Promise进行测试，本文中使用的是这个类库的简略版。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>首先我们创建一个名为 <code>shouldRejected</code> 的helper函数，用来在刚才的 <code>.then</code> 的例子中，期待测试返回状态为 onRejected 的结果的例子。</p>
</div>
<div id="shouldRejected-test.js" class="listingblock">
<div class="title">shouldRejected-test.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> assert = require(<span class="string"><span class="delimiter">'</span><span class="content">power-assert</span><span class="delimiter">'</span></span>);
<span class="keyword">function</span> <span class="function">shouldRejected</span>(promise) {
    <span class="keyword">return</span> {
        <span class="key"><span class="delimiter">'</span><span class="content">catch</span><span class="delimiter">'</span></span>: <span class="keyword">function</span> (fn) {
            <span class="keyword">return</span> promise.then(<span class="keyword">function</span> () {
                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">Expected promise to be rejected but it was fulfilled</span><span class="delimiter">'</span></span>);
            }, <span class="keyword">function</span> (reason) {
                fn.call(promise, reason);
            });
        }
    };
}
it(<span class="string"><span class="delimiter">'</span><span class="content">should be rejected</span><span class="delimiter">'</span></span>, <span class="keyword">function</span> () {
    <span class="keyword">var</span> promise = Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">human error</span><span class="delimiter">'</span></span>));
    <span class="keyword">return</span> shouldRejected(promise).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
        assert(error.message === <span class="string"><span class="delimiter">'</span><span class="content">human error</span><span class="delimiter">'</span></span>);
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>shouldRejected</code> 函数接收一个promise对象作为参数，并且返回一个带有 <code>catch</code> 方法的对象。</p>
</div>
<div class="paragraph">
<p>在这个 <code>catch</code> 中可以使用和 onRejected 里一样的代码，因此我们可以在 <code>catch</code> 使用基于 assertion 方法的测试代码。</p>
</div>
<div class="paragraph">
<p>在 <code>shouldRejected</code> 外部，都是类似如下、和普通的promise处理大同小异的代码。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将需要测试的promise对象传递给 <code>shouldRejected</code> 方法</p>
</li>
<li>
<p>在返回的对象的 <code>catch</code> 方法中编写进行onRejected处理的代码</p>
</li>
<li>
<p>在onRejected里使用assertion进行判断</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在使用 <code>shouldRejected</code> 函数的时候，如果是 Fulfilled 被调用了的话，则会throw一个异常，测试也会失败。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">promise.then(failTest, <span class="keyword">function</span>(error){
    assert(error.message === <span class="string"><span class="delimiter">'</span><span class="content">human error</span><span class="delimiter">'</span></span>);
});
<span class="comment">// == 几乎这两段代码是同样的意思</span>
shouldRejected(promise).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    assert(error.message === <span class="string"><span class="delimiter">'</span><span class="content">human error</span><span class="delimiter">'</span></span>);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>shouldRejected</code> 这样的helper函数，测试代码也会变得很直观。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch3_Testing/img/promise-test.png" alt="Promise onRejected test">
</div>
<div class="title">Figure 10. Promise onRejected test</div>
</div>
<div class="paragraph">
<p>像上面一样，我们也可以编写一个测试promise对象期待结果为Fulfilled的 <code>shouldFulfilled</code> helper函数。</p>
</div>
<div id="shouldFulfilled-test.js" class="listingblock">
<div class="title">shouldFulfilled-test.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> assert = require(<span class="string"><span class="delimiter">'</span><span class="content">power-assert</span><span class="delimiter">'</span></span>);
<span class="keyword">function</span> <span class="function">shouldFulfilled</span>(promise) {
    <span class="keyword">return</span> {
        <span class="key"><span class="delimiter">'</span><span class="content">then</span><span class="delimiter">'</span></span>: <span class="keyword">function</span> (fn) {
            <span class="keyword">return</span> promise.then(<span class="keyword">function</span> (value) {
                fn.call(promise, value);
            }, <span class="keyword">function</span> (reason) {
                <span class="keyword">throw</span> reason;
            });
        }
    };
}
it(<span class="string"><span class="delimiter">'</span><span class="content">should be fulfilled</span><span class="delimiter">'</span></span>, <span class="keyword">function</span> () {
    <span class="keyword">var</span> promise = Promise.resolve(<span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>);
    <span class="keyword">return</span> shouldFulfilled(promise).then(<span class="keyword">function</span> (value) {
        assert(value === <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>);
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这和上面的 <a href="#shouldRejected-test.js">shouldRejected-test.js</a> 结构基本相同，只不过返回对象的 <code>catch</code> 方法变为了 <code>then</code> ，promise.then的两个参数也调换了。</p>
</div>
</div>
<div class="sect3">
<h4 id="__16">3.3.2. 小结</h4>
<div class="paragraph">
<p>在本小节我们学习了如何编写针对Promise特定状态的测试代码，以及如何使用便于测试的helper函数。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这里我们使用到的 <code>shouldFulfilled</code> 和 <code>shouldRejected</code> 也可以在下面的类库中找到。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/azu/promise-test-helper">azu/promise-test-helper</a>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>此外，本小节中的helper方法都是以 <a href="#mocha-promise">Mocha对Promise的支持</a> 为前提的，
在 <a href="#done-promise-test">基于<code>done</code> 的测试</a> 中使用的话可能会比较麻烦。</p>
</div>
<div class="paragraph">
<p>是使用基于测试框架对Promis的支持，还是使用基于类似<code>done</code> 这样回调风格的测试方式，每个人都可以自由的选择，只是风格问题，我觉得倒没必要去争一个孰优孰劣。</p>
</div>
<div class="paragraph">
<p>比如在 <a href="http://coffeescript.org/">CoffeeScript</a>下进行测试的话，由于CoffeeScript 会隐式的使用return返回，所以使用 <code>done</code> 的话可能更容易理解一些。</p>
</div>
<div class="paragraph">
<p>对Promise进行测试比对通常的异步函数进行测试坑更多，虽说采取什么样的测试方法是个人的自由，但是在同一项目中采取前后风格一致的测试则是非常重要。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter4-advanced-promise">4. Chapter.4 - Advanced</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在这一章里，我们会基于前面学到的内容，再深入了解一下Promise里的一些高级内容，加深对Promise的理解。</p>
</div>
<div class="sect2">
<h3 id="promise-library">4.1. Promise的实现类库（Library）</h3>
<div class="paragraph">
<p>在本小节里，我们将不打算对浏览器实现的Promise进行说明，而是要介绍一些第三方实现的和Promise兼容的类库。</p>
</div>
<div class="sect3">
<h4 id="__17">4.1.1. 为什么需要这些类库？</h4>
<div class="paragraph">
<p>为什么需要这些类库呢？我想有些读者不免会有此疑问。首先能想到的原因是有些运行环境并不支持 <a href="#es6-promises">ES6 Promises</a> 。</p>
</div>
<div class="iframe-wrapper" style="width: 100%; height: 350px; overflow: auto; -webkit-overflow-scrolling: touch;">
<iframe src="http://caniuse.com/promises/embed/agents=desktop" width="100%" height="350px"></iframe>
</div>
<div class="paragraph">
<p>当我们在网上查找Promise的实现类库的时候，有一个因素是首先要考虑的，那就是是否具有 <a href="#promises-aplus">Promises/A+兼容性</a> 。</p>
</div>
<div class="paragraph">
<p><a href="#promises-aplus">Promises/A+</a> 是 <a href="#es6-promises">ES6 Promises</a> 的前身，Promise的 <code>then</code> 也是来自于此的基于社区的规范。</p>
</div>
<div class="paragraph">
<p>如果说一个类库兼容 Promises/A+ 的话，那么就是说它除了具有标准的 <code>then</code> 方法之外，很多情况下也说明此类库还支持 <code>Promise.all</code> 和 <code>catch</code> 等功能。</p>
</div>
<div class="paragraph">
<p>但是 Promises/A+ 实际上只是定义了关于 <code>Promise#then</code> 的规范，所以有些类库可能实现了其它诸如 <code>all</code> 或 <code>catch</code> 等功能，但是可能名字却不一样。</p>
</div>
<div class="paragraph">
<p>如果我们说一个类库具有 <code>then</code> 兼容性的话，实际上指的是 <a href="#Thenable">Thenable</a> ，它通过使用 <a href="#Promise.resolve">Promise.resolve</a> 基于ES6 Promise的规定，进行promise对象的变换。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ES6 Promise 里关于promise对象的规定包括在使用
<code>catch</code> 方法，或使用 <code>Promise.all</code> 进行处理的时候不能出现错误。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_polyfill">4.1.2. Polyfill和扩展类库</h4>
<div class="paragraph">
<p>在这些Promise的实现类库中，我们这里主要对两种类型的类库进行介绍。</p>
</div>
<div class="paragraph">
<p>一种是被称为 Polyfill （这是一款英国产品，就是装修刮墙用的腻子，其意义可想而知&#8201;&#8212;&#8201;译者注）的类库，另一种是即具有 <a href="#promises-aplus">Promises/A+兼容性</a> ，又增加了自己独特功能的类库。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
Promise的实现类库数量非常之多，这里我们只是介绍了其中有限的几个。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="promise-polyfill">Polyfill</h5>
<div class="paragraph">
<p>只需要在浏览器中加载Polyfill类库，就能使用IE10等或者还没有提供对Promise支持的浏览器中使用Promise里规定的方法。</p>
</div>
<div class="paragraph">
<p>也就是说如果加载了Polyfill类库，就能在还不支持Promise的环境中，运行本文中的各种示例代码。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://github.com/jakearchibald/es6-promise">jakearchibald/es6-promise</a></dt>
<dd>
<p>一个兼容 ES6 Promises 的Polyfill类库。
它基于 <a href="https://github.com/tildeio/rsvp.js">RSVP.js</a> 这个兼容 Promises/A+ 的类库，
它只是 RSVP.js 的一个子集，只实现了Promises 规定的 API。</p>
</dd>
<dt class="hdlist1"><a href="https://github.com/yahoo/ypromise">yahoo/ypromise</a></dt>
<dd>
<p>这是一个独立版本的 <a href="http://yuilibrary.com/">YUI</a> 的 Promise Polyfill，具有和 ES6 Promises 的兼容性。
本书的示例代码也都是基于这个 ypromise 的 Polyfill 来在线运行的。</p>
</dd>
<dt class="hdlist1"><a href="https://github.com/getify/native-promise-only/">getify/native-promise-only</a></dt>
<dd>
<p>以作为ES6 Promises的polyfill为目的的类库
它严格按照ES6 Promises的规范设计，没有添加在规范中没有定义的功能。
如果运行环境有原生的Promise支持的话，则优先使用原生的Promise支持。</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_promise">Promise扩展类库</h5>
<div class="paragraph">
<p>Promise扩展类库除了实现了Promise中定义的规范之外，还增加了自己独自定义的功能。</p>
</div>
<div class="paragraph">
<p>Promise扩展类库数量非常的多，我们只介绍其中两个比较有名的类库。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://github.com/kriskowal/q">kriskowal/q</a></dt>
<dd>
<p>类库 <code>Q</code> 实现了 Promises 和 Deferreds 等规范。
它自2009年开始开发，还提供了面向Node.js的文件IO API <a href="https://github.com/kriskowal/q-io">Q-IO</a> 等，
是一个在很多场景下都能用得到的类库。</p>
</dd>
<dt class="hdlist1"><a href="https://github.com/petkaantonov/bluebird">petkaantonov/bluebird</a></dt>
<dd>
<p>这个类库除了兼容 Promise 规范之外，还扩展了取消promise对象的运行，取得promise的运行进度，以及错误处理的扩展检测等非常丰富的功能，此外它在实现上还在性能问题下了很大的功夫。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Q 和 Bluebird 这两个类库除了都能在浏览器里运行之外，充实的API reference也是其特征。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/kriskowal/q/wiki/API-Reference">API Reference · kriskowal/q Wiki</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Q等文档里详细介绍了Q的Deferred和jQuery里的Deferred有哪些异同，以及要怎么进行迁移 <a href="https://github.com/kriskowal/q/wiki/Coming-from-jQuery">Coming from jQuery</a> 等都进行了详细的说明。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/petkaantonov/bluebird/blob/master/API.md">bluebird/API.md at master · petkaantonov/bluebird</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Bluebird的文档除了提供了使用Promise丰富的实现方式之外，还涉及到了在出现错误时的对应方法以及
<a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns">Promise中的反模式</a> 等内容。</p>
</div>
<div class="paragraph">
<p>这两个类库的文档写得都很友好，即使我们不使用这两个类库，阅读一下它们的文档也具有一定的参考价值。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__18">4.1.3. 总结</h4>
<div class="paragraph">
<p>本小节介绍了Promise的实现类库中的 Polyfill 和扩展类库这两种。</p>
</div>
<div class="paragraph">
<p>Promise的实现类库种类繁多，到底选择哪个来使用完全看自己的喜好了。</p>
</div>
<div class="paragraph">
<p>但是由于这些类库实现的 Promise 同时具有 Promises/A+ 或 ES6 Promises 共通的接口，所以在使用某一类库的时候，有时候也可以参考一下其他类库的代码或者扩展功能。</p>
</div>
<div class="paragraph">
<p>熟练掌握Promise中的共通概念，进而能在实际中能对这些技术运用自如，这也是本书的写作目的之一。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="resolve-thenable">4.2. Promise.resolve和Thenable</h3>
<div class="paragraph">
<p>在 <a href="#ch2-promise-resolve">第二章的Promise.resolve</a> 中我们已经说过， <code>Promise.resolve</code> 的最大特征之一就是可以将thenable的对象转换为promise对象。</p>
</div>
<div class="paragraph">
<p>在本小节里，我们将学习一下利用将thenable对象转换为promise对象这个功能都能具体做些什么事情。</p>
</div>
<div class="sect3">
<h4 id="__web_notifications_thenable">4.2.1. 将Web Notifications转换为thenable对象</h4>
<div class="paragraph">
<p>这里我们以桌面通知 API <a href="https://developer.mozilla.org/ja/docs/Web/API/notification">Web Notifications</a> 为例进行说明。</p>
</div>
<div class="paragraph">
<p>关于Web Notifications API的详细信息可以参考下面的网址。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.mozilla.org/zh-TW/docs/WebAPI/Using_Web_Notifications">使用 Web Notifications - WebAPI | MDN</a></p>
</li>
<li>
<p><a href="http://caniuse.com/notifications">Can I use Web Notifications</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>简单来说，Web Notifications API就是能像以下代码那样通过 <code>new Notification</code> 来显示通知消息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">new</span> Notification(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hi!</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，为了显示通知消息，我们需要在运行 <code>new Notification</code> 之前，先获得用户的许可。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch4_AdvancedPromises/img/notification-dialog.png" alt="确认是否允许Notification的对话框">
</div>
<div class="title">Figure 11. 确认是否允许Notification的对话框</div>
</div>
<div class="paragraph">
<p>用户在这个是否允许Notification的对话框选择后的结果，会通过 <code>Notification.permission</code> 传给我们的程序，它的值可能是允许("granted")或拒绝("denied")这二者之一。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
是否允许Notification对话框中的可选项，在Firefox中除了允许、拒绝之外，还增加了 <em>永久有效</em> 和 <em>会话范围内有效</em> 两种额外选项，当然 <code>Notification.permission</code> 的值都是一样的。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在程序中可以通过 <code>Notification.requestPermission()</code> 来弹出是否允许Notification对话框，
用户选择的结果会通过 <code>status</code> 参数传给回调函数。</p>
</div>
<div class="paragraph">
<p>从这个回调函数我们也可以看出来，用户选择允许还是拒绝通知是异步进行的。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Notification.requestPermission(<span class="keyword">function</span> (status) {
    <span class="comment">// status的值为 &quot;granted&quot; 或 &quot;denied&quot;</span>
    console.log(status);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>到用户收到并显示通知为止，整体的处理流程如下所示。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>显示是否允许通知的对话框，并异步处理用户选择结果</p>
</li>
<li>
<p>如果用户允许的话，则通过 <code>new Notification</code> 显示通知消息。这又分两种情况</p>
<div class="ulist">
<ul>
<li>
<p>用户之前已经允许过</p>
</li>
<li>
<p>当场弹出是否允许桌面通知对话框</p>
</li>
</ul>
</div>
</li>
<li>
<p>当用户不允许的时候，不执行任何操作</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>虽然上面说到了几种情景，但是最终结果就是用户允许或者拒绝，可以总结为如下两种模式。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">允许时("granted")</dt>
<dd>
<p>使用 <code>new Notification</code> 创建通知消息</p>
</dd>
<dt class="hdlist1">拒绝时("denied")</dt>
<dd>
<p>没有任何操作</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>这两种模式是不是觉得有在哪里看过的感觉？
呵呵，用户的选择结果，正和在Promise中promise对象变为 Fulfilled 或 Rejected 状态非常类似。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">resolve(成功)时 == 用户允许("granted")</dt>
<dd>
<p>调用 <code>onFulfilled</code> 方法</p>
</dd>
<dt class="hdlist1">reject(失败)时 == 用户拒绝("denied")</dt>
<dd>
<p>调用 <code>onRejected</code> 函数</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>是不是我们可以用Promise的方式去编写桌面通知的代码呢？我们先从回调函数风格的代码入手看看到底怎么去做。</p>
</div>
</div>
<div class="sect3">
<h4 id="_web_notification_wrapper">4.2.2. Web Notification 包装函数（wrapper）</h4>
<div class="paragraph">
<p>首先，我们以回到函数风格的代码对上面的Web Notification API包装函数进行重写，新代码如下所示。</p>
</div>
<div id="notification-callback.js" class="listingblock executable">
<div class="title">notification-callback.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">notifyMessage</span>(message, options, callback) {
    <span class="keyword">if</span> (Notification &amp;&amp; Notification.permission === <span class="string"><span class="delimiter">'</span><span class="content">granted</span><span class="delimiter">'</span></span>) {
        <span class="keyword">var</span> notification = <span class="keyword">new</span> Notification(message, options);
        callback(<span class="predefined-constant">null</span>, notification);
    } <span class="keyword">else</span> <span class="keyword">if</span> (Notification.requestPermission) {
        Notification.requestPermission(<span class="keyword">function</span> (status) {
            <span class="keyword">if</span> (Notification.permission !== status) {
                Notification.permission = status;
            }
            <span class="keyword">if</span> (status === <span class="string"><span class="delimiter">'</span><span class="content">granted</span><span class="delimiter">'</span></span>) {
                <span class="keyword">var</span> notification = <span class="keyword">new</span> Notification(message, options);
                callback(<span class="predefined-constant">null</span>, notification);
            } <span class="keyword">else</span> {
                callback(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">user denied</span><span class="delimiter">'</span></span>));
            }
        });
    } <span class="keyword">else</span> {
        callback(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">doesn</span><span class="char">\'</span><span class="content">t support Notification API</span><span class="delimiter">'</span></span>));
    }
}
<span class="comment">// 运行实例</span>
<span class="comment">// 第二个参数是传给 `Notification` 的option对象</span>
notifyMessage(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hi!</span><span class="delimiter">&quot;</span></span>, {}, <span class="keyword">function</span> (error, notification) {
    <span class="keyword">if</span>(error){
        <span class="keyword">return</span> console.error(error);
    }
    console.log(notification);<span class="comment">// 通知对象</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在回调风格的代码里，当用户拒绝接收通知的时候， <code>error</code> 会被设置值，而如果用户同意接收通知的时候，则会显示通知消息并且 <code>notification</code> 会被设置值。</p>
</div>
<div class="listingblock">
<div class="title">回调函数接收error和notification两个参数</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">callback</span>(error, notification){

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面，我想再将这个回调函数风格的代码使用Promise进行改写。</p>
</div>
</div>
<div class="sect3">
<h4 id="_web_notification_as_promise">4.2.3. Web Notification as Promise</h4>
<div class="paragraph">
<p>基于上述回调风格的 <code>notifyMessage</code> 函数，我们再来创建一个返回promise对象的 <code>notifyMessageAsPromise</code> 方法。</p>
</div>
<div id="notification-as-promise.js" class="listingblock executable">
<div class="title">notification-as-promise.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">notifyMessage</span>(message, options, callback) {
    <span class="keyword">if</span> (Notification &amp;&amp; Notification.permission === <span class="string"><span class="delimiter">'</span><span class="content">granted</span><span class="delimiter">'</span></span>) {
        <span class="keyword">var</span> notification = <span class="keyword">new</span> Notification(message, options);
        callback(<span class="predefined-constant">null</span>, notification);
    } <span class="keyword">else</span> <span class="keyword">if</span> (Notification.requestPermission) {
        Notification.requestPermission(<span class="keyword">function</span> (status) {
            <span class="keyword">if</span> (Notification.permission !== status) {
                Notification.permission = status;
            }
            <span class="keyword">if</span> (status === <span class="string"><span class="delimiter">'</span><span class="content">granted</span><span class="delimiter">'</span></span>) {
                <span class="keyword">var</span> notification = <span class="keyword">new</span> Notification(message, options);
                callback(<span class="predefined-constant">null</span>, notification);
            } <span class="keyword">else</span> {
                callback(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">user denied</span><span class="delimiter">'</span></span>));
            }
        });
    } <span class="keyword">else</span> {
        callback(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">doesn</span><span class="char">\'</span><span class="content">t support Notification API</span><span class="delimiter">'</span></span>));
    }
}
<span class="keyword">function</span> <span class="function">notifyMessageAsPromise</span>(message, options) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        notifyMessage(message, options, <span class="keyword">function</span> (error, notification) {
            <span class="keyword">if</span> (error) {
                reject(error);
            } <span class="keyword">else</span> {
                resolve(notification);
            }
        });
    });
}
<span class="comment">// 运行示例</span>
notifyMessageAsPromise(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hi!</span><span class="delimiter">&quot;</span></span>).then(<span class="keyword">function</span> (notification) {
    console.log(notification);<span class="comment">// 通知对象</span>
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在用户允许接收通知的时候，运行上面的代码，会显示 <code>"Hi!"</code> 消息。</p>
</div>
<div class="paragraph">
<p>当用户接收通知消息的时候， <code>.then</code> 函数会被调用，当用户拒绝接收消息的时候， <code>.catch</code> 方法会被调用。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于浏览器是以网站为单位保存Web Notifications API的许可状态的，所以实际上有下面四种模式存在。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">已经获得用户许可</dt>
<dd>
<p><code>.then</code> 方法被调用</p>
</dd>
<dt class="hdlist1">弹出询问对话框并获得许可</dt>
<dd>
<p><code>.then</code> 方法被调用</p>
</dd>
<dt class="hdlist1">已经是被用户拒绝的状态</dt>
<dd>
<p><code>.catch</code> 方法被调用</p>
</dd>
<dt class="hdlist1">弹出询问对话框并被用户拒绝</dt>
<dd>
<p><code>.catch</code> 方法被调用</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>也就是说，如果使用原生的Web Notifications API的话，那么需要在程序中对上述四种情况都进行处理，我们可以像下面的包装函数那样，将上述四种情况简化为两种以方便处理。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>上面的 <a href="#notification-as-promise.js">notification-as-promise.js</a> 虽然看上去很方便，但是实际上使用的时候，很可能出现 <strong>在不支持Promise的环境下不能使用</strong> 的问题。</p>
</div>
<div class="paragraph">
<p>如果你想编写像<a href="#notification-as-promise.js">notification-as-promise.js</a>这样具有Promise风格和的类库的话，我觉得你有如下的一些选择。</p>
</div>
<div id="promise-library-choice" class="dlist">
<dl>
<dt class="hdlist1">支持Promise的环境是前提</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>需要最终用户保证支持<code>Promise</code></p>
</li>
<li>
<p>在不支持Promise的环境下不能正常工作（即应该出错）。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">在类库中实现<code>Promise</code></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>在类库中实现<code>Promise</code>功能</p>
</li>
<li>
<p>例如） <a href="https://github.com/mozilla/localForage">localForage</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">在回调函数中也应该能够使用 <code>Promise</code></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>用户可以选择合适的使用方式</p>
</li>
<li>
<p>返回Thenable类型</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p><a href="#notification-as-promise.js">notification-as-promise.js</a>就是以<code>Promise</code>存在为前提的写法。</p>
</div>
<div class="paragraph">
<p>回归正文，在这里<a href="#Thenable">Thenable</a>是为了帮助实现<strong>在回调函数中也能使用<code>Promise</code></strong>的一个概念。</p>
</div>
</div>
<div class="sect3">
<h4 id="_web_notifications_as_thenable">4.2.4. Web Notifications As Thenable</h4>
<div class="paragraph">
<p>我们已经说过，<a href="#Thenable">thenable</a>就是一个具有 <code>.then</code>方法的一个对象。下面我们就在<a href="#notification-callback.js">notification-callback.js</a>中增加一个返回值为 <code>thenable</code> 类型的方法。</p>
</div>
<div id="notification-thenable.js" class="listingblock executable">
<div class="title">notification-thenable.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">notifyMessage</span>(message, options, callback) {
    <span class="keyword">if</span> (Notification &amp;&amp; Notification.permission === <span class="string"><span class="delimiter">'</span><span class="content">granted</span><span class="delimiter">'</span></span>) {
        <span class="keyword">var</span> notification = <span class="keyword">new</span> Notification(message, options);
        callback(<span class="predefined-constant">null</span>, notification);
    } <span class="keyword">else</span> <span class="keyword">if</span> (Notification.requestPermission) {
        Notification.requestPermission(<span class="keyword">function</span> (status) {
            <span class="keyword">if</span> (Notification.permission !== status) {
                Notification.permission = status;
            }
            <span class="keyword">if</span> (status === <span class="string"><span class="delimiter">'</span><span class="content">granted</span><span class="delimiter">'</span></span>) {
                <span class="keyword">var</span> notification = <span class="keyword">new</span> Notification(message, options);
                callback(<span class="predefined-constant">null</span>, notification);
            } <span class="keyword">else</span> {
                callback(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">user denied</span><span class="delimiter">'</span></span>));
            }
        });
    } <span class="keyword">else</span> {
        callback(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">doesn</span><span class="char">\'</span><span class="content">t support Notification API</span><span class="delimiter">'</span></span>));
    }
}
<span class="comment">// 返回 `thenable`</span>
<span class="keyword">function</span> <span class="function">notifyMessageAsThenable</span>(message, options) {
    <span class="keyword">return</span> {
        <span class="key"><span class="delimiter">'</span><span class="content">then</span><span class="delimiter">'</span></span>: <span class="keyword">function</span> (resolve, reject) {
            notifyMessage(message, options, <span class="keyword">function</span> (error, notification) {
                <span class="keyword">if</span> (error) {
                    reject(error);
                } <span class="keyword">else</span> {
                    resolve(notification);
                }
            });
        }
    };
}
<span class="comment">// 运行示例</span>
Promise.resolve(notifyMessageAsThenable(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>)).then(<span class="keyword">function</span> (notification) {
    console.log(notification);<span class="comment">// 通知对象</span>
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#notification-thenable.js">notification-thenable.js</a>里增加了一个 <code>notifyMessageAsThenable</code>方法。这个方法返回的对象具备一个<code>then</code>方法。</p>
</div>
<div class="paragraph">
<p><code>then</code>方法的参数和 <code>new Promise(function (resolve, reject){})</code> 一样，在确定时执行 <code>resolve</code> 方法，拒绝时调用 <code>reject</code> 方法。</p>
</div>
<div class="paragraph">
<p><code>then</code> 方法和 <a href="#notification-as-promise.js">notification-as-promise.js</a> 中的 <code>notifyMessageAsPromise</code> 方法完成了同样的工作。</p>
</div>
<div class="paragraph">
<p>我们可以看出， <code>Promise.resolve(thenable)</code> 通过使用了  <code>thenable</code> 这个promise对象，就能利用Promise功能了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Promise.resolve(notifyMessageAsThenable(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>)).then(<span class="keyword">function</span> (notification) {
    console.log(notification);<span class="comment">// 通知对象</span>
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用了Thenable的<a href="#notification-thenable.js">notification-thenable.js</a> 和依赖于Promise的 <a href="#notification-as-promise.js">notification-as-promise.js</a> ，实际上都是非常相似的使用方法。</p>
</div>
<div class="paragraph">
<p><a href="#notification-thenable.js">notification-thenable.js</a> 和 <a href="#notification-as-promise.js">notification-as-promise.js</a>比起来，有以下的不同点。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>类库侧没有提供 <code>Promise</code> 的实现</p>
<div class="ulist">
<ul>
<li>
<p>用户通过 <code>Promise.resolve(thenable)</code> 来自己实现了 <code>Promise</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>作为Promise使用的时候，需要和 <code>Promise.resolve(thenable)</code> 一起配合使用</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过使用<a href="#Thenable">Thenable</a>对象，我们可以实现类似已有的回调式风格和Promise风格中间的一种实现风格。</p>
</div>
</div>
<div class="sect3">
<h4 id="__19">4.2.5. 总结</h4>
<div class="paragraph">
<p>在本小节我们主要学习了什么是Thenable，以及如何通过<code>Promise.resolve(thenable)</code> 使用Thenable，将其作为promise对象来使用。</p>
</div>
<div class="paragraph">
<p>Callback&#8201;&#8212;&#8201;Thenable&#8201;&#8212;&#8201;Promise</p>
</div>
<div class="paragraph">
<p>Thenable风格表现为位于回调和Promise风格中间的一种状态，作为类库的公开API有点不太成熟，所以并不常见。</p>
</div>
<div class="paragraph">
<p>Thenable本身并不依赖于<code>Promise</code>功能，但是Promise之外也没有使用Thenable的方式，所以可以认为Thenable间接依赖于Promise。</p>
</div>
<div class="paragraph">
<p>另外，用户需要对 <code>Promise.resolve(thenable)</code> 有所理解才能使用好Thenable，因此作为类库的公开API有一部分会比较难。和公开API相比，更多情况下是在内部使用Thenable。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在编写异步处理的类库的时候，推荐采用先编写回调风格的函数，然后再转换为公开API这种方式。</p>
</div>
<div class="paragraph">
<p>貌似Node.js的Core module就采用了这种方式，除了类库提供的基本回调风格的函数之外，用户也可以通过Promise或者Generator等自己擅长的方式进行实现。</p>
</div>
<div class="paragraph">
<p>最初就是以能被Promise使用为目的的类库，或者其本身依赖于Promise等情况下，我想将返回promise对象的函数作为公开API应该也没什么问题。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="__thenable">什么时候该使用Thenable？</h5>
<div class="paragraph">
<p>那么，又是在什么情况下应该使用Thenable呢？</p>
</div>
<div class="paragraph">
<p>恐怕最可能被使用的是在 <a href="#promise-library">Promise类库</a> 之间进行相互转换了。</p>
</div>
<div class="paragraph">
<p>比如，类库Q的Promise实例为Q promise对象，提供了 <a href="#es6-promises">ES6 Promises</a> 的promise对象不具备的方法。Q promise对象提供了 <code>promise.finally(callback)</code> 和 <code>promise.nodeify(callback)</code> 等方法。</p>
</div>
<div class="paragraph">
<p>如果你想将ES6 Promises的promise对象转换为Q promise的对象，轮到Thenable大显身手的时候就到了。</p>
</div>
<div class="listingblock">
<div class="title">使用thenable将promise对象转换为Q promise对象</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> Q = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">Q</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// 这是一个ES6的promise对象</span>
<span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve){
    resolve(<span class="integer">1</span>);
});
<span class="comment">// 变换为Q promise对象</span>
Q(promise).then(<span class="keyword">function</span>(value){
    console.log(value);
}).<span class="keyword">finally</span>(<span class="keyword">function</span>(){ <i class="conum" data-value="1"></i><b>(1)</b>
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">finally</span><span class="delimiter">&quot;</span></span>);
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>因为是Q promise对象所以可以使用 <code>finally</code> 方法</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>上面代码中最开始被创建的promise对象具备<code>then</code>方法，因此是一个Thenable对象。我们可以通过<code>Q(thenable)</code>方法，将这个Thenable对象转换为Q promise对象。</p>
</div>
<div class="paragraph">
<p>可以说它的机制和 <code>Promise.resolve(thenable)</code> 一样，当然反过来也一样。</p>
</div>
<div class="paragraph">
<p>像这样，Promise类库虽然都有自己类型的promise对象，但是它们之间可以通过Thenable这个共通概念，在类库之间（当然也包括native Promise）进行promise对象的相互转换。</p>
</div>
<div class="paragraph">
<p>我们看到，就像上面那样，Thenable多在类库内部实现中使用，所以从外部来说不会经常看到Thenable的使用。但是我们必须牢记Thenable是Promise中一个非常重要的概念。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="not-throw-use-reject">4.3. 使用reject而不是throw</h3>
<div class="paragraph">
<p>Promise的构造函数，以及被 <code>then</code> 调用执行的函数基本上都可以认为是在
<code>try...catch</code> 代码块中执行的，所以在这些代码中即使使用 <code>throw</code> ，程序本身也不会因为异常而终止。</p>
</div>
<div class="paragraph">
<p>如果在Promise中使用 <code>throw</code> 语句的话，会被 <code>try...catch</code> 住，最终promise对象也变为Rejected状态。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve, reject){
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>);
});
promise.<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);<span class="comment">// =&gt; &quot;message&quot;</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>代码像这样其实运行时倒也不会有什么问题，但是如果想把 <a href="#promise-states">promise对象状态</a> 设置为Rejected状态的话，使用 <code>reject</code> 方法则更显得合理。</p>
</div>
<div class="paragraph">
<p>所以上面的代码可以改写为下面这样。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve, reject){
    reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>));
});
promise.<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);<span class="comment">// =&gt; &quot;message&quot;</span>
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>其实我们也可以这么来考虑，在出错的时候我们并没有调用 <code>throw</code> 方法，而是使用了 <code>reject</code> ，那么给 <code>reject</code> 方法传递一个Error类型的对象也就很好理解了。</p>
</div>
<div class="sect3">
<h4 id="__reject">4.3.1. 使用reject有什么优点？</h4>
<div class="paragraph">
<p>话说回来，为什么在想将promise对象的状态设置为Rejected的时候应该使用 <code>reject</code> 而不是 <code>throw</code> 呢？</p>
</div>
<div class="paragraph">
<p>首先是因为我们很难区分 <code>throw</code> 是我们主动抛出来的，还是因为真正的其它 <strong>异常</strong> 导致的。</p>
</div>
<div class="paragraph">
<p>比如在使用Chrome浏览器的时候，Chrome的开发者工具提供了在程序发生异常的时候自动在调试器中break的功能。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch4_AdvancedPromises/img/chrome_on_caught_exception.png" alt="Pause On Caught Exceptions">
</div>
<div class="title">Figure 12. Pause On Caught Exceptions</div>
</div>
<div class="paragraph">
<p>当我们开启这个功能的时候，在执行到下面代码中的 <code>throw</code> 时就会触发调试器的break行为。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve, reject){
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>本来这是和调试没有关系的地方，也因为在Promise中的 <code>throw</code> 语句被break了，这也严重的影响了浏览器提供的此功能的正常使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="__then_reject">4.3.2. 在then中进行reject</h4>
<div class="paragraph">
<p>在Promise构造函数中，有一个用来指定 <code>reject</code> 方法的参数，使用这个参数而不是依靠
<code>throw</code> 将promise对象的状态设置为Rejected状态非常简单。</p>
</div>
<div class="paragraph">
<p>那么如果像下面那样想在 <code>then</code> 中进行reject的话该怎么办呢？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = Promise.resolve();
promise.then(<span class="keyword">function</span> (value) {
    setTimeout(<span class="keyword">function</span> () {
        <span class="comment">// 经过一段时间后还没处理完的话就进行reject - 2</span>
    }, <span class="integer">1000</span>);
    <span class="comment">// 比较耗时的处理 - 1</span>
    somethingHardWork();
}).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    <span class="comment">// 超时错误 - 3</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的超时处理，需要在 <code>then</code> 中进行 <code>reject</code> 方法调用，但是传递给当前的回调函数的参数只有前面的一promise对象，这该怎么办呢？</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
关于使用Promise进行超时处理的具体实现方法可以参考 <a href="#race-delay-timeout">使用Promise.race和delay取消XHR请求</a> 中的详细说明。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在这里我们再次回忆下 <code>then</code> 的工作原理。</p>
</div>
<div class="paragraph">
<p>在 <code>then</code> 中注册的回调函数可以通过 <code>return</code> 返回一个值，这个返回值会传给后面的 <code>then</code> 或 <code>catch</code> 中的回调函数。</p>
</div>
<div class="paragraph">
<p>而且return的返回值类型不光是简单的字面值，还可以是复杂的对象类型，比如promise对象等。</p>
</div>
<div class="paragraph">
<p>这时候，如果返回的是promise对象的话，那么根据这个promise对象的状态，在下一个 <code>then</code> 中注册的回调函数中的onFulfilled和onRejected的哪一个会被调用也是能确定的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = Promise.resolve();
promise.then(<span class="keyword">function</span> () {
    <span class="keyword">var</span> retPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="comment">// resolve or reject 的状态决定 onFulfilled or onRejected 的哪个方法会被调用</span>
    });
    <span class="keyword">return</span> retPromise;<i class="conum" data-value="1"></i><b>(1)</b>
}).then(onFulfilled, onRejected);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>后面的then调用哪个回调函数是由promise对象的状态来决定的</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>也就是说，这个 <code>retPromise</code> 对象状态为Rejected的时候，会调用后面then中的 <code>onRejected</code> 方法，这样就实现了即使在 <code>then</code> 中不使用 <code>throw</code> 也能进行reject处理了。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> onRejected = console.error.bind(console);
<span class="keyword">var</span> promise = Promise.resolve();
promise.then(<span class="keyword">function</span> () {
    <span class="keyword">var</span> retPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
       reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">this promise is rejected</span><span class="delimiter">&quot;</span></span>));
    });
    <span class="keyword">return</span> retPromise;
}).<span class="keyword">catch</span>(onRejected);</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <a href="#Promise.reject">Promise.reject</a> 的话还能再将代码进行简化。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> onRejected = console.error.bind(console);
<span class="keyword">var</span> promise = Promise.resolve();
promise.then(<span class="keyword">function</span> () {
    <span class="keyword">return</span> Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">this promise is rejected</span><span class="delimiter">&quot;</span></span>));
}).<span class="keyword">catch</span>(onRejected);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__20">4.3.3. 总结</h4>
<div class="paragraph">
<p>在本小节我们主要学习了</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用 <code>reject</code> 会比使用 <code>throw</code> 安全</p>
</li>
<li>
<p>在 <code>then</code> 中使用reject的方法</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>也许实际中我们可能不常使用 <code>reject</code> ，但是比起来不假思索的使用 <code>throw</code> 来说，使用 <code>reject</code> 的好处还是很多的。</p>
</div>
<div class="paragraph">
<p>关于上面讲的内容的比较详细的例子，大家可以参考在
<a href="#race-delay-timeout">使用Promise.race和delay取消XHR请求</a> 小节的介绍。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="deferred-and-promise">4.4. Deferred和Promise</h3>
<div class="paragraph">
<p>这一节我们来简单介绍下Deferred和Promise之间的关系</p>
</div>
<div class="sect3">
<h4 id="__deferred">4.4.1. 什么是Deferred？</h4>
<div class="paragraph">
<p>说起Promise，我想大家一定同时也听说过Deferred这个术语。比如 <a href="http://api.jquery.com/category/deferred-object/">jQuery.Deferred</a> 和 <a href="http://cho45.stfuawsc.com/jsdeferred/">JSDeferred</a> 等，一定都是大家非常熟悉的内容了。</p>
</div>
<div class="paragraph">
<p>Deferred和Promise不同，它没有共通的规范，每个Library都是根据自己的喜好来实现的。</p>
</div>
<div class="paragraph">
<p>在这里，我们打算以 <a href="http://api.jquery.com/category/deferred-object/">jQuery.Deferred</a> 类似的实现为中心进行介绍。</p>
</div>
</div>
<div class="sect3">
<h4 id="_deferred_promise">4.4.2. Deferred和Promise的关系</h4>
<div class="paragraph">
<p>简单来说，Deferred和Promise具有如下的关系。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Deferred 拥有 Promise</p>
</li>
<li>
<p>Deferred 具备对 Promise的状态进行操作的特权方法（图中的"特権メソッド"）</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch4_AdvancedPromises/img/deferred-and-promise.png" alt="Deferred和Promise">
</div>
<div class="title">Figure 13. Deferred和Promise</div>
</div>
<div class="paragraph">
<p>我想各位看到此图应该就很容易理解了，Deferred和Promise并不是处于竞争的关系，而是Deferred内涵了Promise。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
这是jQuery.Deferred结构的简化版。当然也有的Deferred实现并没有内涵Promise。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>光看图的话也许还难以理解，下面我们就看看看怎么通过Promise来实现Deferred。</p>
</div>
</div>
<div class="sect3">
<h4 id="_deferred_top_on_promise">4.4.3. Deferred top on Promise</h4>
<div class="paragraph">
<p>基于Promise实现Deferred的例子。</p>
</div>
<div id="deferred.js" class="listingblock">
<div class="title">deferred.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">Deferred</span>() {
    <span class="local-variable">this</span>.promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="local-variable">this</span>._resolve = resolve;
        <span class="local-variable">this</span>._reject = reject;
    }.bind(<span class="local-variable">this</span>));
}
Deferred.prototype.<span class="function">resolve</span> = <span class="keyword">function</span> (value) {
    <span class="local-variable">this</span>._resolve.call(<span class="local-variable">this</span>.promise, value);
};
Deferred.prototype.<span class="function">reject</span> = <span class="keyword">function</span> (reason) {
    <span class="local-variable">this</span>._reject.call(<span class="local-variable">this</span>.promise, reason);
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们再将之前使用Promise实现的 <a href="#xhr-promise.js"><code>getURL</code></a> 用Deferred改写一下。</p>
</div>
<div id="xhr-deferred.js" class="listingblock executable">
<div class="title">xhr-deferred.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">Deferred</span>() {
    <span class="local-variable">this</span>.promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="local-variable">this</span>._resolve = resolve;
        <span class="local-variable">this</span>._reject = reject;
    }.bind(<span class="local-variable">this</span>));
}
Deferred.prototype.<span class="function">resolve</span> = <span class="keyword">function</span> (value) {
    <span class="local-variable">this</span>._resolve.call(<span class="local-variable">this</span>.promise, value);
};
Deferred.prototype.<span class="function">reject</span> = <span class="keyword">function</span> (reason) {
    <span class="local-variable">this</span>._reject.call(<span class="local-variable">this</span>.promise, reason);
};
<span class="keyword">function</span> <span class="function">getURL</span>(URL) {
    <span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();
    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
    req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
    req.<span class="function">onload</span> = <span class="keyword">function</span> () {
        <span class="keyword">if</span> (req.status === <span class="integer">200</span>) {
            deferred.resolve(req.responseText);
        } <span class="keyword">else</span> {
            deferred.reject(<span class="keyword">new</span> Error(req.statusText));
        }
    };
    req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
        deferred.reject(<span class="keyword">new</span> Error(req.statusText));
    };
    req.send();
    <span class="keyword">return</span> deferred.promise;
}
<span class="comment">// 运行示例</span>
<span class="keyword">var</span> URL = <span class="string"><span class="delimiter">&quot;</span><span class="content">http://httpbin.org/get</span><span class="delimiter">&quot;</span></span>;
getURL(URL).then(<span class="keyword">function</span> <span class="function">onFulfilled</span>(value){
    console.log(value);
}).<span class="keyword">catch</span>(console.error.bind(console));</code></pre>
</div>
</div>
<div class="paragraph">
<p>所谓的能对Promise状态进行操作的特权方法，指的就是能对promise对象的状态进行resolve、reject等调用的方法，而通常的Promise的话只能在通过构造函数传递的方法之内对promise对象的状态进行操作。</p>
</div>
<div class="paragraph">
<p>我们来看看Deferred和Promise相比在实现上有什么异同。</p>
</div>
<div class="listingblock executable">
<div class="title">xhr-promise.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">getURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onload</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.status === <span class="integer">200</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
<span class="comment">// 运行示例</span>
<span class="keyword">var</span> URL = <span class="string"><span class="delimiter">&quot;</span><span class="content">http://httpbin.org/get</span><span class="delimiter">&quot;</span></span>;
getURL(URL).then(<span class="keyword">function</span> <span class="function">onFulfilled</span>(value){
    console.log(value);
}).<span class="keyword">catch</span>(console.error.bind(console));</code></pre>
</div>
</div>
<div class="paragraph">
<p>对比上述两个版本的 <code>getURL</code> ，我们发现它们有如下不同。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Deferred 的话不需要将代码用Promise括起来</p>
<div class="ulist">
<ul>
<li>
<p>由于没有被嵌套在函数中，可以减少一层缩进</p>
</li>
<li>
<p>反过来没有Promise里的错误处理逻辑</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>在以下方面，它们则完成了同样的工作。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>整体处理流程</p>
<div class="ulist">
<ul>
<li>
<p>调用 <code>resolve</code>、<code>reject</code> 的时机</p>
</li>
</ul>
</div>
</li>
<li>
<p>函数都返回了promise对象</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于Deferred包含了Promise，所以大体的流程还是差不多的，不过Deferred有用对Promise进行操作的特权方法，以及高度自由的对流程控制进行自由定制。</p>
</div>
<div class="paragraph">
<p>比如在Promise一般都会在构造函数中编写主要处理逻辑，对 <code>resolve</code>、<code>reject</code> 方法的调用时机也基本是很确定的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject){
    <span class="comment">// 在这里进行promise对象的状态确定</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>而使用Deferred的话，并不需要将处理逻辑写成一大块代码，只需要先创建deferred对象，可以在任何时机对 <code>resolve</code>、<code>reject</code> 方法进行调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();

<span class="comment">// 可以在随意的时机对 `resolve`、`reject` 方法进行调用</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面我们只是简单的实现了一个 <strong>Deferred</strong> ，我想你已经看到了它和 <strong>Promise</strong> 之间的差异了吧。</p>
</div>
<div class="paragraph">
<p>如果说Promise是用来对值进行抽象的话，Deferred则是对处理还没有结束的状态或操作进行抽象化的对象，我们也可以从这一层的区别来理解一下这两者之间的差异。</p>
</div>
<div class="paragraph">
<p>换句话说，Promise代表了一个对象，这个对象的状态现在还不确定，但是未来一个时间点它的状态要么变为正常值（FulFilled），要么变为异常值（Rejected）；而Deferred对象表示了一个处理还没有结束的这种事实，在它的处理结束的时候，可以通过Promise来取得处理结果。</p>
</div>
<div class="paragraph">
<p>如果各位读者还想深入了解一下Deferred的话，可以参考下面的这些资料。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://blog.mediumequalsmessage.com/promise-deferred-objects-in-javascript-pt1-theory-and-semantics">Promise &amp; Deferred objects in JavaScript Pt.1: Theory and Semantics.</a></p>
</li>
<li>
<p><a href="http://skitazaki.appspot.com/translation/twisted-intro-ja/index.html">Twisted 入门 — Twisted Intro</a></p>
</li>
<li>
<p><a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern">Promise anti patterns · petkaantonov/bluebird Wiki</a></p>
</li>
<li>
<p><a href="https://github.com/kriskowal/q/wiki/Coming-from-jQuery">Coming from jQuery · kriskowal/q Wiki</a></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Deferred最初是在Python的 <a href="https://twistedmatrix.com/trac/">Twisted</a> 框架中被提出来的概念。
在JavaScript领域可以认为它是由 <a href="http://mochi.github.io/mochikit/doc/html/MochiKit/Async.html">MochiKit.Async</a> 、 <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/Deferred.html">dojo/Deferred</a> 等Library引入的。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="race-delay-timeout">4.5. 使用Promise.race和delay取消XHR请求</h3>
<div class="paragraph">
<p>在本小节中，作为在第<a href="#ch2-promise-race">2章</a>所学的 <a href="#Promise.race"><code>Promise.race</code></a> 的具体例子，我们来看一下如何使用Promise.race来实现超时机制。</p>
</div>
<div class="paragraph">
<p>当然XHR有一个 <a href="https://developer.mozilla.org/ja/docs/XMLHttpRequest/Synchronous_and_Asynchronous_Requests">timeout</a> 属性，使用该属性也可以简单实现超时功能，但是为了能支持多个XHR同时超时或者其他功能，我们采用了容易理解的异步方式在XHR中通过超时来实现取消正在进行中的操作。</p>
</div>
<div class="sect3">
<h4 id="__promise_3">4.5.1. 让Promise等待指定时间</h4>
<div class="paragraph">
<p>首先我们来看一下如何在Promise中实现超时。</p>
</div>
<div class="paragraph">
<p>所谓超时就是要在经过一定时间后进行某些操作，使用 <code>setTimeout</code> 的话很好理解。</p>
</div>
<div class="paragraph">
<p>首先我们来串讲一个单纯的在Promise中调用  <code>setTimeout</code> 的函数。</p>
</div>
<div id="delayPromise.js" class="listingblock">
<div class="title">delayPromise.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">delayPromise</span>(ms) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(resolve, ms);
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>delayPromise(ms)</code> 返回一个在经过了参数指定的毫秒数后进行onFulfilled操作的promise对象，这和直接使用 <code>setTimeout</code> 函数比较起来只是编码上略有不同，如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">setTimeout(<span class="keyword">function</span> () {
    alert(<span class="string"><span class="delimiter">&quot;</span><span class="content">已经过了100ms！</span><span class="delimiter">&quot;</span></span>);
}, <span class="integer">100</span>);
<span class="comment">// == 几乎同样的操作</span>
delayPromise(<span class="integer">100</span>).then(<span class="keyword">function</span> () {
    alert(<span class="string"><span class="delimiter">&quot;</span><span class="content">已经过了100ms！</span><span class="delimiter">&quot;</span></span>);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里 <strong>promise对象</strong> 这个概念非常重要，请切记。</p>
</div>
</div>
<div class="sect3">
<h4 id="_promise_race">4.5.2. Promise.race中的超时</h4>
<div class="paragraph">
<p>让我们回顾一下静态方法 <code>Promise.race</code> ，它的作用是在任何一个promise对象进入到确定（解决）状态后就继续进行后续处理，如下面的例子所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> winnerPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(<span class="keyword">function</span> () {
            console.log(<span class="string"><span class="delimiter">'</span><span class="content">this is winner</span><span class="delimiter">'</span></span>);
            resolve(<span class="string"><span class="delimiter">'</span><span class="content">this is winner</span><span class="delimiter">'</span></span>);
        }, <span class="integer">4</span>);
    });
<span class="keyword">var</span> loserPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(<span class="keyword">function</span> () {
            console.log(<span class="string"><span class="delimiter">'</span><span class="content">this is loser</span><span class="delimiter">'</span></span>);
            resolve(<span class="string"><span class="delimiter">'</span><span class="content">this is loser</span><span class="delimiter">'</span></span>);
        }, <span class="integer">1000</span>);
    });
<span class="comment">// 第一个promise变为resolve后程序停止</span>
Promise.race([winnerPromise, loserPromise]).then(<span class="keyword">function</span> (value) {
    console.log(value);    <span class="comment">// =&gt; 'this is winner'</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以将刚才的 <a href="#delayPromise.js">delayPromise</a> 和其它promise对象一起放到
<code>Promise.race</code> 中来是实现简单的超时机制。</p>
</div>
<div id="simple-timeout-promise.js" class="listingblock">
<div class="title">simple-timeout-promise.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">delayPromise</span>(ms) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(resolve, ms);
    });
}
<span class="keyword">function</span> <span class="function">timeoutPromise</span>(promise, ms) {
    <span class="keyword">var</span> timeout = delayPromise(ms).then(<span class="keyword">function</span> () {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">Operation timed out after </span><span class="delimiter">'</span></span> + ms + <span class="string"><span class="delimiter">'</span><span class="content"> ms</span><span class="delimiter">'</span></span>);
        });
    <span class="keyword">return</span> Promise.race([promise, timeout]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>函数 <code>timeoutPromise(比较对象promise, ms)</code> 接收两个参数，第一个是需要使用超时机制的promise对象，第二个参数是超时时间，它返回一个由 <code>Promise.race</code> 创建的相互竞争的promise对象。</p>
</div>
<div class="paragraph">
<p>之后我们就可以使用 <code>timeoutPromise</code> 编写下面这样的具有超时机制的代码了。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">delayPromise</span>(ms) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(resolve, ms);
    });
}
<span class="keyword">function</span> <span class="function">timeoutPromise</span>(promise, ms) {
    <span class="keyword">var</span> timeout = delayPromise(ms).then(<span class="keyword">function</span> () {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">Operation timed out after </span><span class="delimiter">'</span></span> + ms + <span class="string"><span class="delimiter">'</span><span class="content"> ms</span><span class="delimiter">'</span></span>);
        });
    <span class="keyword">return</span> Promise.race([promise, timeout]);
}
<span class="comment">// 运行示例</span>
<span class="keyword">var</span> taskPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve){
    <span class="comment">// 随便一些什么处理</span>
    <span class="keyword">var</span> delay = Math.random() * <span class="integer">2000</span>;
    setTimeout(<span class="keyword">function</span>(){
        resolve(delay + <span class="string"><span class="delimiter">&quot;</span><span class="content">ms</span><span class="delimiter">&quot;</span></span>);
    }, delay);
});
timeoutPromise(taskPromise, <span class="integer">1000</span>).then(<span class="keyword">function</span>(value){
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">taskPromise在规定时间内结束 : </span><span class="delimiter">&quot;</span></span> + value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">发生超时</span><span class="delimiter">&quot;</span></span>, error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然在发生超时的时候抛出了异常，但是这样的话我们就不能区分这个异常到底是<em>普通的错误</em>还是<em>超时错误</em>了。</p>
</div>
<div class="paragraph">
<p>为了能区分这个 <code>Error</code> 对象的类型，我们再来定义一个<code>Error</code> 对象的子类 <code>TimeoutError</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="__error">4.5.3. 定制Error对象</h4>
<div class="paragraph">
<p><code>Error</code> 对象是ECMAScript的内建（build in）对象。</p>
</div>
<div class="paragraph">
<p>但是由于stack trace等原因我们不能完美的创建一个继承自 <code>Error</code> 的类，不过在这里我们的目的只是为了和Error有所区别，我们将创建一个 <code>TimeoutError</code> 类来实现我们的目的。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在ECMAScript6中可以使用 <code>class</code> 语法来定义类之间的继承关系。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="reserved">class</span> MyError <span class="reserved">extends</span> Error{
    <span class="comment">// 继承了Error类的对象</span>
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为了让我们的 <code>TimeoutError</code> 能支持类似 <code>error instanceof TimeoutError</code> 的使用方法，我们还需要进行如下工作。</p>
</div>
<div id="TimeoutError.js" class="listingblock">
<div class="title">TimeoutError.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">copyOwnFrom</span>(target, source) {
    Object.getOwnPropertyNames(source).forEach(<span class="keyword">function</span> (propName) {
        Object.defineProperty(target, propName, Object.getOwnPropertyDescriptor(source, propName));
    });
    <span class="keyword">return</span> target;
}
<span class="keyword">function</span> <span class="function">TimeoutError</span>() {
    <span class="keyword">var</span> superInstance = Error.apply(<span class="predefined-constant">null</span>, <span class="local-variable">arguments</span>);
    copyOwnFrom(<span class="local-variable">this</span>, superInstance);
}
TimeoutError.prototype = Object.create(Error.prototype);
TimeoutError.prototype.constructor = TimeoutError;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们定义了 <code>TimeoutError</code> 类和构造函数，这个类继承了Error的prototype。</p>
</div>
<div class="paragraph">
<p>它的使用方法和普通的 <code>Error</code> 对象一样，使用 <code>throw</code> 语句即可，如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(){
    <span class="keyword">throw</span> TimeoutError(<span class="string"><span class="delimiter">&quot;</span><span class="content">timeout</span><span class="delimiter">&quot;</span></span>);
});

promise.<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.log(error <span class="keyword">instanceof</span> TimeoutError);<span class="comment">// true</span>
});
</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这个 <code>TimeoutError</code> 对象，我们就能很容易区分捕获的到底是因为超时而导致的错误，还是其他原因导致的Error对象了。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>本章里介绍的继承JavaScript内建对象的方法可以参考 <a href="http://speakingjs.com/es5/ch28.html">Chapter 28. Subclassing Built-ins</a> ，那里有详细的说明。此外 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">Error - JavaScript | MDN</a> 也针对Error对象进行了详细说明。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="__xhr">4.5.4. 通过超时取消XHR操作</h4>
<div class="paragraph">
<p>到这里，我想各位读者都已经对如何使用Promise来取消一个XHR请求都有一些思路了吧。</p>
</div>
<div class="paragraph">
<p>取消XHR操作本身的话并不难，只需要调用 <code>XMLHttpRequest</code> 对象的 <code>abort()</code> 方法就可以了。</p>
</div>
<div class="paragraph">
<p>为了能在外部调用 <code>abort()</code> 方法，我们先对之前本节出现的 <a href="#xhr-promise.js"><code>getURL</code></a> 进行简单的扩展，<code>cancelableXHR</code> 方法除了返回一个包装了XHR的promise对象之外，还返回了一个用于取消该XHR请求的<code>abort</code>方法。</p>
</div>
<div id="delay-race-cancel.js" class="listingblock">
<div class="title">delay-race-cancel.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">cancelableXHR</span>(URL) {
    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
    <span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
            req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
            req.<span class="function">onload</span> = <span class="keyword">function</span> () {
                <span class="keyword">if</span> (req.status === <span class="integer">200</span>) {
                    resolve(req.responseText);
                } <span class="keyword">else</span> {
                    reject(<span class="keyword">new</span> Error(req.statusText));
                }
            };
            req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
                reject(<span class="keyword">new</span> Error(req.statusText));
            };
            req.<span class="function">onabort</span> = <span class="keyword">function</span> () {
                reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">abort this request</span><span class="delimiter">'</span></span>));
            };
            req.send();
        });
    <span class="keyword">var</span> <span class="function">abort</span> = <span class="keyword">function</span> () {
        <span class="comment">// 如果request还没有结束的话就执行abort</span>
        <span class="comment">// https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest</span>
        <span class="keyword">if</span> (req.readyState !== XMLHttpRequest.UNSENT) {
            req.abort();
        }
    };
    <span class="keyword">return</span> {
        <span class="key">promise</span>: promise,
        <span class="key">abort</span>: abort
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这些问题都明了之后，剩下只需要进行Promise处理的流程进行编码即可。大体的流程就像下面这样。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>通过 <code>cancelableXHR</code> 方法取得包装了XHR的promise对象和取消该XHR请求的方法</p>
</li>
<li>
<p>在 <code>timeoutPromise</code> 方法中通过 <code>Promise.race</code> 让XHR的包装promise和超时用promise进行竞争。</p>
<div class="ulist">
<ul>
<li>
<p>XHR在超时前返回结果的话</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>和正常的promise一样，通过 <code>then</code> 返回请求结果</p>
</li>
</ol>
</div>
</li>
<li>
<p>发生超时的时候</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>抛出 <code>throw TimeoutError</code> 异常并被 <code>catch</code></p>
</li>
<li>
<p>catch的错误对象如果是 <code>TimeoutError</code> 类型的话，则调用 <code>abort</code> 方法取消XHR请求</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>将上面的步骤总结一下的话，代码如下所示。</p>
</div>
<div id="delay-race-cancel-play.js" class="listingblock executable">
<div class="title">delay-race-cancel-play.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">copyOwnFrom</span>(target, source) {
    Object.getOwnPropertyNames(source).forEach(<span class="keyword">function</span> (propName) {
        Object.defineProperty(target, propName, Object.getOwnPropertyDescriptor(source, propName));
    });
    <span class="keyword">return</span> target;
}
<span class="keyword">function</span> <span class="function">TimeoutError</span>() {
    <span class="keyword">var</span> superInstance = Error.apply(<span class="predefined-constant">null</span>, <span class="local-variable">arguments</span>);
    copyOwnFrom(<span class="local-variable">this</span>, superInstance);
}
TimeoutError.prototype = Object.create(Error.prototype);
TimeoutError.prototype.constructor = TimeoutError;
<span class="keyword">function</span> <span class="function">delayPromise</span>(ms) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(resolve, ms);
    });
}
<span class="keyword">function</span> <span class="function">timeoutPromise</span>(promise, ms) {
    <span class="keyword">var</span> timeout = delayPromise(ms).then(<span class="keyword">function</span> () {
            <span class="keyword">return</span> Promise.reject(<span class="keyword">new</span> TimeoutError(<span class="string"><span class="delimiter">'</span><span class="content">Operation timed out after </span><span class="delimiter">'</span></span> + ms + <span class="string"><span class="delimiter">'</span><span class="content"> ms</span><span class="delimiter">'</span></span>));
        });
    <span class="keyword">return</span> Promise.race([promise, timeout]);
}
<span class="keyword">function</span> <span class="function">cancelableXHR</span>(URL) {
    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
    <span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
            req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
            req.<span class="function">onload</span> = <span class="keyword">function</span> () {
                <span class="keyword">if</span> (req.status === <span class="integer">200</span>) {
                    resolve(req.responseText);
                } <span class="keyword">else</span> {
                    reject(<span class="keyword">new</span> Error(req.statusText));
                }
            };
            req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
                reject(<span class="keyword">new</span> Error(req.statusText));
            };
            req.<span class="function">onabort</span> = <span class="keyword">function</span> () {
                reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">abort this request</span><span class="delimiter">'</span></span>));
            };
            req.send();
        });
    <span class="keyword">var</span> <span class="function">abort</span> = <span class="keyword">function</span> () {
        <span class="comment">// 如果request还没有结束的话就执行abort</span>
        <span class="comment">// https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest</span>
        <span class="keyword">if</span> (req.readyState !== XMLHttpRequest.UNSENT) {
            req.abort();
        }
    };
    <span class="keyword">return</span> {
        <span class="key">promise</span>: promise,
        <span class="key">abort</span>: abort
    };
}
<span class="keyword">var</span> object = cancelableXHR(<span class="string"><span class="delimiter">'</span><span class="content">http://httpbin.org/get</span><span class="delimiter">'</span></span>);
<span class="comment">// main</span>
timeoutPromise(object.promise, <span class="integer">1000</span>).then(<span class="keyword">function</span> (contents) {
    console.log(<span class="string"><span class="delimiter">'</span><span class="content">Contents</span><span class="delimiter">'</span></span>, contents);
}).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    <span class="keyword">if</span> (error <span class="keyword">instanceof</span> TimeoutError) {
        object.abort();
        <span class="keyword">return</span> console.log(error);
    }
    console.log(<span class="string"><span class="delimiter">'</span><span class="content">XHR Error :</span><span class="delimiter">'</span></span>, error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码就通过在一定的时间内变为解决状态的promise对象实现了超时处理。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
通常进行开发的情况下，由于这些逻辑会频繁使用，因此将这些代码分割保存在不同的文件应该是一个不错的选择。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_promise_2">4.5.5. promise和操作方法</h4>
<div class="paragraph">
<p>在前面的 <a href="#delay-race-cancel.js"><code>cancelableXHR</code></a> 中，promise对象及其操作方法都是在一个对象中返回的，看起来稍微有些不太好理解。</p>
</div>
<div class="paragraph">
<p>从代码组织的角度来说一个函数只返回一个值（promise对象）是一个非常好的习惯，但是由于在外面不能访问 <code>cancelableXHR</code> 方法中创建的 <code>req</code> 变量，所以我们需要编写一个专门的函数（上面的例子中的<code>abort</code>）来对这些内部对象进行处理。</p>
</div>
<div class="paragraph">
<p>当然也可以考虑到对返回的promise对象进行扩展，使其支持<code>abort</code>方法，但是由于promise对象是对值进行抽象化的对象，如果不加限制的增加操作用的方法的话，会使整体变得非常复杂。</p>
</div>
<div class="paragraph">
<p>大家都知道一个函数做太多的工作都不认为是一个好的习惯，因此我们不会让一个函数完成所有功能，也许像下面这样对函数进行分割是一个不错的选择。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>返回包含XHR的promise对象</p>
</li>
<li>
<p>接收promise对象作为参数并取消该对象中的XHR请求</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>将这些处理整理为一个模块的话，以后扩展起来也方便，一个函数所做的工作也会比较精炼，代码也会更容易阅读和维护。</p>
</div>
<div class="paragraph">
<p>我们有很多方法来创建一个模块（AMD,CommonJS,ES6 module etc..），在这里，我们将会把前面的 <code>cancelableXHR</code> 整理为一个Node.js的模块使用。</p>
</div>
<div id="cancelableXHR.js" class="listingblock">
<div class="title">cancelableXHR.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
<span class="keyword">var</span> requestMap = {};
<span class="keyword">function</span> <span class="function">createXHRPromise</span>(URL) {
    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
    <span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onreadystatechange</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.readyState === XMLHttpRequest.DONE) {
                <span class="keyword">delete</span> requestMap[URL];
            }
        };
        req.<span class="function">onload</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.status === <span class="integer">200</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.<span class="function">onabort</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">abort this req</span><span class="delimiter">'</span></span>));
        };
        req.send();
    });
    requestMap[URL] = {
        <span class="key">promise</span>: promise,
        <span class="key">request</span>: req
    };
    <span class="keyword">return</span> promise;
}

<span class="keyword">function</span> <span class="function">abortPromise</span>(promise) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> promise === <span class="string"><span class="delimiter">&quot;</span><span class="content">undefined</span><span class="delimiter">&quot;</span></span>) {
        <span class="keyword">return</span>;
    }
    <span class="keyword">var</span> request;
    Object.keys(requestMap).some(<span class="keyword">function</span> (URL) {
        <span class="keyword">if</span> (requestMap[URL].promise === promise) {
            request = requestMap[URL].request;
            <span class="keyword">return</span> <span class="predefined-constant">true</span>;
        }
    });
    <span class="keyword">if</span> (request != <span class="predefined-constant">null</span> &amp;&amp; request.readyState !== XMLHttpRequest.UNSENT) {
        request.abort();
    }
}
module.exports.createXHRPromise = createXHRPromise;
module.exports.abortPromise = abortPromise;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用方法也非常简单，我们通过 <code>createXHRPromise</code> 方法得到XHR的promise对象，当想对这个XHR进行<code>abort</code>操作的时候，将这个promise对象传递给  <code>abortPromise(promise)</code> 方法就可以了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> cancelableXHR = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">./cancelableXHR</span><span class="delimiter">&quot;</span></span>);

<span class="keyword">var</span> xhrPromise = cancelableXHR.createXHRPromise(<span class="string"><span class="delimiter">'</span><span class="content">http://httpbin.org/get</span><span class="delimiter">'</span></span>);<i class="conum" data-value="1"></i><b>(1)</b>
xhrPromise.<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    <span class="comment">// 调用 abort 抛出的错误</span>
});
cancelableXHR.abortPromise(xhrPromise);<i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建包装了XHR的promise对象</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>取消在1中创建的promise对象的请求操作</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="__21">4.5.6. 总结</h4>
<div class="paragraph">
<p>在这里我们学到了如下内容。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>经过一定时间后变为解决状态的delayPromise</p>
</li>
<li>
<p>基于delayPromise和Promise.race的超时实现方式</p>
</li>
<li>
<p>取消XHR promise请求</p>
</li>
<li>
<p>通过模块化实现promise对象和操作的分离</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Promise能非常灵活的进行处理流程的控制，为了充分发挥它的能力，我们需要注意不要将一个函数写的过于庞大冗长，而是应该将其分割成更小更简单的处理，并对之前JavaScript中提到的机制进行更深入的了解。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="promise-done">4.6. 什么是 Promise.prototype.done ？</h3>
<div class="paragraph">
<p>如果你使用过其他的Promise实现类库的话，可能见过用<code>done</code>代替<code>then</code>的例子。</p>
</div>
<div class="paragraph">
<p>这些类库都提供了 <code>Promise.prototype.done</code> 方法，使用起来也和 <code>then</code> 一样，但是这个方法并不会返回promise对象。</p>
</div>
<div class="paragraph">
<p>虽然 <a href="#es6-promises">ES6 Promises</a>和<a href="#promises-aplus">Promises/A+</a>等在设计上并没有对<code>Promise.prototype.done</code> 做出任何规定，但是很多实现类库都提供了该方法的实现。</p>
</div>
<div class="paragraph">
<p>在本小节中，我们将会学习什么是 <code>Promise.prototype.done</code> ，以及为什么很多类库都提供了对该方法的支持。</p>
</div>
<div class="sect3">
<h4 id="__done">4.6.1. 使用done的代码示例</h4>
<div class="paragraph">
<p>看一下实际使用done的代码的例子的话，应该就非常容易理解 <code>done</code> 方法的行为了。</p>
</div>
<div id="promise-done-example.js" class="listingblock executable">
<div class="title">promise-done-example.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">if</span> (<span class="keyword">typeof</span> Promise.prototype.done === <span class="string"><span class="delimiter">'</span><span class="content">undefined</span><span class="delimiter">'</span></span>) {
    Promise.prototype.<span class="function">done</span> = <span class="keyword">function</span> (onFulfilled, onRejected) {
        <span class="local-variable">this</span>.then(onFulfilled, onRejected).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
            setTimeout(<span class="keyword">function</span> () {
                <span class="keyword">throw</span> error;
            }, <span class="integer">0</span>);
        });
    };
}
<span class="keyword">var</span> promise = Promise.resolve();
promise.done(<span class="keyword">function</span> () {
    JSON.parse(<span class="string"><span class="delimiter">'</span><span class="content">this is not json</span><span class="delimiter">'</span></span>);    <span class="comment">// =&gt; SyntaxError: JSON.parse</span>
});
<span class="comment">// =&gt; 请打开浏览器的开发者工具中的控制台窗口看一下</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面我们已经说过，promise设计规格并没有对 <code>Promise.prototype.done</code>做出任何规定，因此在使用的时候，你可以使用已有类库提供的实现，也可以自己去实现。</p>
</div>
<div class="paragraph">
<p>我们会在后面讲述如何去自己实现，首先我们这里先对使用 <code>then</code> 和使用 <code>done</code>这两种方式进行一下比较。</p>
</div>
<div class="listingblock executable">
<div class="title">使用then的场景</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = Promise.resolve();
promise.then(<span class="keyword">function</span> () {
    JSON.parse(<span class="string"><span class="delimiter">&quot;</span><span class="content">this is not json</span><span class="delimiter">&quot;</span></span>);
}).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    console.error(error);<span class="comment">// =&gt; &quot;SyntaxError: JSON.parse&quot;</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>从上面我们可以看出，两者之间有以下不同点。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>done</code> 并不返回promise对象</p>
<div class="ulist">
<ul>
<li>
<p>也就是说，在done之后不能使用 <code>catch</code> 等方法组成方法链</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>done</code> 中发生的异常会被直接抛给外面</p>
<div class="ulist">
<ul>
<li>
<p>也就是说，不会进行Promise的错误处理（Error Handling）</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于<code>done</code> 不会返回promise对象，所以我们不难理解它只能出现在一个方法链的最后。</p>
</div>
<div class="paragraph">
<p>此外，我们已经介绍过了Promise具有强大的错误处理机制，而<code>done</code>则会在函数中跳过错误处理，直接抛出异常。</p>
</div>
<div class="paragraph">
<p>为什么很多类库都提供了这个和Promise功能相矛盾的函数呢？看一下下面Promise处理失败的例子，也许我们多少就能理解其中原因了吧。</p>
</div>
</div>
<div class="sect3">
<h4 id="__22">4.6.2. 消失的错误</h4>
<div class="paragraph">
<p>Promise虽然具备了强大的错误处理机制，但是（调试工具不能顺利运行的时候）这个功能会导致人为错误（human error）更加复杂，这也是它的一个缺点。</p>
</div>
<div class="paragraph">
<p>也许你还记得，我们在 <a href="#then-or-catch">then or catch?</a> 中也看到了类似的内容。</p>
</div>
<div class="paragraph">
<p>像下面那样，我们看一个能返回promise对象的函数。</p>
</div>
<div id="json-promise.js" class="listingblock">
<div class="title">json-promise.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">JSONPromise</span>(value) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        resolve(JSON.parse(value));
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个函数将接收到的参数传递给 <code>JSON.parse</code> ，并返回一个基于<code>JSON.parse</code>的promise对象。</p>
</div>
<div class="paragraph">
<p>我们可以像下面那样使用这个Promise函数，由于 <code>JSON.parse</code> 会解析失败并抛出一个异常，该异常会被 <code>catch</code> 捕获。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">JSONPromise</span>(value) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        resolve(JSON.parse(value));
    });
}
<span class="comment">// 运行示例</span>
<span class="keyword">var</span> string = <span class="string"><span class="delimiter">&quot;</span><span class="content">非合法json编码字符串</span><span class="delimiter">&quot;</span></span>;
JSONPromise(string).then(<span class="keyword">function</span> (object) {
    console.log(object);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    <span class="comment">// =&gt; JSON.parse抛出异常时</span>
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果这个解析失败的异常被正常捕获的话则没什么问题，但是如果编码时忘记了处理该异常，一旦出现异常，那么查找异常发生的源头将会变得非常棘手，这就是使用promise需要注意的一面。</p>
</div>
<div class="listingblock">
<div class="title">忘记了使用catch进行异常处理的的例子</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> string = <span class="string"><span class="delimiter">&quot;</span><span class="content">非合法json编码字符串</span><span class="delimiter">&quot;</span></span>;
JSONPromise(string).then(<span class="keyword">function</span> (object) {
    console.log(object);
}); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>虽然抛出了异常，但是没有对该异常进行处理</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果是<code>JSON.parse</code> 这样比较好找的例子还算好说，如果是拼写错误的话，那么发生了Syntax Error错误的话将会非常麻烦。</p>
</div>
<div class="listingblock">
<div class="title">typo错误</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> string = <span class="string"><span class="delimiter">&quot;</span><span class="content">{}</span><span class="delimiter">&quot;</span></span>;
JSONPromise(string).then(<span class="keyword">function</span> (object) {
    conosle.log(object);<i class="conum" data-value="1"></i><b>(1)</b>
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>存在conosle这个拼写错误</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这这个例子里，我们错把 <code>console</code> 拼成了 <code>conosle</code> ，因此会发生如下错误。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>ReferenceError: conosle is not defined</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>但是，由于Promise的try-catch机制，这个问题可能会被内部消化掉。
如果在调用的时候每次都无遗漏的进行 <code>catch</code> 处理的话当然最好了，但是如果在实现的过程中出现了这个例子中的错误的话，那么进行错误排除的工作也会变得困难。</p>
</div>
<div class="paragraph">
<p>这种错误被内部消化的问题也被称为 <em>unhandled rejection</em> ，从字面上看就是在Rejected时没有找到相应处理的意思。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这种unhandled rejection错误到底有多难检查，也依赖于Promise的实现。
比如 <a href="https://github.com/yahoo/ypromise">ypromise</a> 在检测到 unhandled rejection 错误的时候，会在控制台上提示相应的信息。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Promise rejected but no error handlers were registered to it</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>另外， <a href="https://github.com/petkaantonov/bluebird">Bluebird</a> 在比较明显的人为错误，即ReferenceError等错误的时候，会直接显示到控制台上。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>"Possibly unhandled ReferenceError. conosle is not defined</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>原生（Native）的 Promise实现为了应对同样问题，提供了GC-based unhandled rejection tracking功能。</p>
</div>
<div class="paragraph">
<p>该功能是在promise对象被垃圾回收器回收的时候，如果是unhandled rejection的话，则进行错误显示的一种机制。</p>
</div>
<div class="paragraph">
<p><a href="https://twitter.com/domenic/status/461154989856264192">Firefox</a> 或 <a href="https://code.google.com/p/v8/issues/detail?id=3093">Chrome</a> 的原生Promise都进行了部分实现。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_done">4.6.3. done的实现</h4>
<div class="paragraph">
<p>作为方法论，在Promise中 <code>done</code> 是怎么解决上面提到的错误被忽略呢？
其实它的方法很简单直接，那就是必须要进行错误处理。</p>
</div>
<div class="paragraph">
<p>由于可以在 Promise上实现 <code>done</code> 方法，因此我们看看如何对 <code>Promise.prototype.done</code> 这个Promise的prototype进行扩展。</p>
</div>
<div id="promise-prototype-done.js" class="listingblock">
<div class="title">promise-prototype-done.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
<span class="keyword">if</span> (<span class="keyword">typeof</span> Promise.prototype.done === <span class="string"><span class="delimiter">&quot;</span><span class="content">undefined</span><span class="delimiter">&quot;</span></span>) {
    Promise.prototype.<span class="function">done</span> = <span class="keyword">function</span> (onFulfilled, onRejected) {
        <span class="local-variable">this</span>.then(onFulfilled, onRejected).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
            setTimeout(<span class="keyword">function</span> () {
                <span class="keyword">throw</span> error;
            }, <span class="integer">0</span>);
        });
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么它是如何将异常抛到Promise的外面的呢？其实这里我们利用的是在setTimeout中使用throw方法，直接将异常抛给了外部。</p>
</div>
<div class="listingblock">
<div class="title">setTimeout的回调函数中抛出异常</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">try</span>{
    setTimeout(<span class="keyword">function</span> <span class="function">callback</span>() {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">error</span><span class="delimiter">&quot;</span></span>);<i class="conum" data-value="1"></i><b>(1)</b>
    }, <span class="integer">0</span>);
}<span class="keyword">catch</span>(error){
    console.error(error);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这个例外不会被捕获</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>关于为什么异步的<code>callback</code>中抛出的异常不会被捕获的原因，可以参考下面内容。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://techblog.yahoo.co.jp/programming/javascript_error/">JavaScript和异步错误处理 - Yahoo! JAPAN Tech Blog（日语博客）</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>仔细看一下 <a href="#promise-prototype-done.js"><code>Promise.prototype.done</code></a>的代码，我们会发现这个函数什么也没 <code>return</code> 。
也就是说， <code>done</code>按照「Promise chain在这里将会中断，如果出现了异常，直接抛到promise外面即可」的原则进行了处理。</p>
</div>
<div class="paragraph">
<p>如果实现和运行环境实现的比较完美的话，就可以进行 <em>unhandled rejection</em> 检测，<code>done</code>也不一定是必须的了。
另外像本小节中的 <a href="#promise-prototype-done.js"><code>Promise.prototype.done</code></a>一样，<code>done</code>也可以在既有的Promise之上进行实现，也可以说它没有进入到
<a href="#es6-promises">ES6 Promises</a>的设计规范之中。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
本文中的 <code>Promise.prototype.done</code> 的实现方法参考了 <a href="https://www.promisejs.org/">promisejs.org</a> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="__23">4.6.4. 总结</h4>
<div class="paragraph">
<p>在本小节中，我们学习了 <a href="https://github.com/kriskowal/q/wiki/API-Reference#promisedoneonfulfilled-onrejected-onprogress">Q</a> 、 <a href="https://github.com/petkaantonov/bluebird">Bluebird</a> 和 <a href="https://github.com/cscott/prfun#promisedone&#8212;undefined">prfun</a> 等Promise类库提供的 <code>done</code> 的基础和实现细节，以及<code>done</code>方法和 <code>then</code> 方法有什么区别等内容。</p>
</div>
<div class="paragraph">
<p>我们也学到了 <code>done</code> 有以下两个特点。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>done</code> 中出现的错误会被作为异常抛出</p>
</li>
<li>
<p>终结 Promise chain</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>和 <a href="#then-or-catch">then or catch?</a> 中说到的一样，由Promise内部消化掉的错误，随着调试工具或者类库的改进，大多数情况下也许已经不是特别大的问题了。</p>
</div>
<div class="paragraph">
<p>此外，由于 <code>done</code> 不会有返回值，因此不能在它之后进行方法链的创建，为了实现Promise方法风格上的统一，我们也可以使用<code>done</code>方法。</p>
</div>
<div class="paragraph">
<p><a href="#es6-promises">ES6 Promises</a> 本身提供的功能并不是特别多。
因此，我想很多时候可能需要我们自己进行扩展或者使用第三方类库。</p>
</div>
<div class="paragraph">
<p>我们好不容易将异步处理统一采用Promise进行统一处理，但是如果做过头了，也会将系统变得特别复杂，因此，保持风格的统一是Promise作为抽象对象非常重要的部分。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 <a href="http://blog.getify.com/promises-part-4/">Promises: The Extension Problem (part 4) | getiblog</a> 中，介绍了一些如何编写Promise扩展程序的方法。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>扩展 <code>Promise.prototype</code> 的方法</p>
</li>
<li>
<p>利用 Wrapper/Delegate 创建抽象层</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外，关于 Delegate 的详细使用方法，也可以参考 <a href="http://speakingjs.com/es5/ch28.html">Chapter 28. Subclassing Built-ins</a> ，那里有详细的说明。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="promise-and-method-chain">4.7. Promise和方法链（method chain）</h3>
<div class="paragraph">
<p>在Promise中你可以将 <code>then</code> 和 <code>catch</code> 等方法连在一起写。这非常像DOM或者jQuery中的方法链。</p>
</div>
<div class="paragraph">
<p>一般的方法链都通过返回 <code>this</code> 将多个方法串联起来。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>关于如何创建方法链，可以从参考 <a href="http://taiju.hatenablog.com/entry/20100307/1267962826">方法链的创建方法 - 余味（日语博客）</a> 等资料。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>另一方面，由于Promise <a href="#then-return-new-promise">每次都会返回一个新的promise对象</a> ，所以从表面上看和一般的方法链几乎一模一样。</p>
</div>
<div class="paragraph">
<p>在本小节里，我们会在不改变已有采用方法链编写的代码的外部接口的前提下，学习如何在内部使用Promise进行重写。</p>
</div>
<div class="sect3">
<h4 id="_fs">4.7.1. fs中的方法链</h4>
<div class="paragraph">
<p>我们下面将会以 <a href="http://nodejs.org/api/fs.html">Node.js中的fs</a> 为例进行说明。</p>
</div>
<div class="paragraph">
<p>此外，这里的例子我们更重视代码的易理解性，因此从实际上来说这个例子可能并不算太实用。</p>
</div>
<div id="fs-method-chain.js" class="listingblock">
<div class="title">fs-method-chain.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
<span class="keyword">var</span> fs = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">fs</span><span class="delimiter">&quot;</span></span>);
<span class="keyword">function</span> <span class="function">File</span>() {
    <span class="local-variable">this</span>.lastValue = <span class="predefined-constant">null</span>;
}
<span class="comment">// Static method for File.prototype.read</span>
File.<span class="function">read</span> = <span class="keyword">function</span> <span class="function">FileRead</span>(filePath) {
    <span class="keyword">var</span> file = <span class="keyword">new</span> File();
    <span class="keyword">return</span> file.read(filePath);
};
File.prototype.<span class="function">read</span> = <span class="keyword">function</span> (filePath) {
    <span class="local-variable">this</span>.lastValue = fs.readFileSync(filePath, <span class="string"><span class="delimiter">&quot;</span><span class="content">utf-8</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
File.prototype.<span class="function">transform</span> = <span class="keyword">function</span> (fn) {
    <span class="local-variable">this</span>.lastValue = fn.call(<span class="local-variable">this</span>, <span class="local-variable">this</span>.lastValue);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
File.prototype.<span class="function">write</span> = <span class="keyword">function</span> (filePath) {
    <span class="local-variable">this</span>.lastValue = fs.writeFileSync(filePath, <span class="local-variable">this</span>.lastValue);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
module.exports = File;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个模块可以将类似下面的 read &#8594; transform &#8594; write 这一系列处理，通过组成一个方法链来实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> File = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">./fs-method-chain</span><span class="delimiter">&quot;</span></span>);
<span class="keyword">var</span> inputFilePath = <span class="string"><span class="delimiter">&quot;</span><span class="content">input.txt</span><span class="delimiter">&quot;</span></span>,
    outputFilePath = <span class="string"><span class="delimiter">&quot;</span><span class="content">output.txt</span><span class="delimiter">&quot;</span></span>;
File.read(inputFilePath)
    .transform(<span class="keyword">function</span> (content) {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;&gt;</span><span class="delimiter">&quot;</span></span> + content;
    })
    .write(outputFilePath);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>transform</code> 接收一个方法作为参数，该方法对其输入参数进行处理。在这个例子里，我们对通过read读取的数据在前面加上了 <code>&gt;&gt;</code> 字符串。</p>
</div>
</div>
<div class="sect3">
<h4 id="__promise_fs">4.7.2. 基于Promise的fs方法链</h4>
<div class="paragraph">
<p>下面我们就在不改变刚才的<a href="#fs-method-chain.js">方法链</a>对外接口的前提下，采用Promise对内部实现进行重写。</p>
</div>
<div id="fs-promise-chain.js" class="listingblock">
<div class="title">fs-promise-chain.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
<span class="keyword">var</span> fs = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">fs</span><span class="delimiter">&quot;</span></span>);
<span class="keyword">function</span> <span class="function">File</span>() {
    <span class="local-variable">this</span>.promise = Promise.resolve();
}
<span class="comment">// Static method for File.prototype.read</span>
File.<span class="function">read</span> = <span class="keyword">function</span> (filePath) {
    <span class="keyword">var</span> file = <span class="keyword">new</span> File();
    <span class="keyword">return</span> file.read(filePath);
};

File.prototype.<span class="function">then</span> = <span class="keyword">function</span> (onFulfilled, onRejected) {
    <span class="local-variable">this</span>.promise = <span class="local-variable">this</span>.promise.then(onFulfilled, onRejected);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
File.prototype[<span class="string"><span class="delimiter">&quot;</span><span class="content">catch</span><span class="delimiter">&quot;</span></span>] = <span class="keyword">function</span> (onRejected) {
    <span class="local-variable">this</span>.promise = <span class="local-variable">this</span>.promise.<span class="keyword">catch</span>(onRejected);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
File.prototype.<span class="function">read</span> = <span class="keyword">function</span> (filePath) {
    <span class="keyword">return</span> <span class="local-variable">this</span>.then(<span class="keyword">function</span> () {
        <span class="keyword">return</span> fs.readFileSync(filePath, <span class="string"><span class="delimiter">&quot;</span><span class="content">utf-8</span><span class="delimiter">&quot;</span></span>);
    });
};
File.prototype.<span class="function">transform</span> = <span class="keyword">function</span> (fn) {
    <span class="keyword">return</span> <span class="local-variable">this</span>.then(fn);
};
File.prototype.<span class="function">write</span> = <span class="keyword">function</span> (filePath) {
    <span class="keyword">return</span> <span class="local-variable">this</span>.then(<span class="keyword">function</span> (data) {
        <span class="keyword">return</span> fs.writeFileSync(filePath, data)
    });
};
module.exports = File;</code></pre>
</div>
</div>
<div class="paragraph">
<p>新增加的<code>then</code> 和<code>catch</code>都可以看做是指向内部保存的promise对象的别名，而其它部分从对外接口的角度来说都没有改变，使用方法也和原来一样。</p>
</div>
<div class="paragraph">
<p>因此，在使用这个模块的时候我们只需要修改 <code>require</code> 的模块名即可。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> File = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">./fs-promise-chain</span><span class="delimiter">&quot;</span></span>);
<span class="keyword">var</span> inputFilePath = <span class="string"><span class="delimiter">&quot;</span><span class="content">input.txt</span><span class="delimiter">&quot;</span></span>,
    outputFilePath = <span class="string"><span class="delimiter">&quot;</span><span class="content">output.txt</span><span class="delimiter">&quot;</span></span>;
File.read(inputFilePath)
    .transform(<span class="keyword">function</span> (content) {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;&gt;</span><span class="delimiter">&quot;</span></span> + content;
    })
    .write(outputFilePath);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>File.prototype.then</code> 方法会调用
<code>this.promise.then</code> 方法，并将返回的promise对象赋值给了 <code>this.promise</code> 变量这个内部promise对象。</p>
</div>
<div class="paragraph">
<p>这究竟有什么奥妙么？通过以下的伪代码，我们可以更容易理解这背后发生的事情。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> File = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">./fs-promise-chain</span><span class="delimiter">&quot;</span></span>);
File.read(inputFilePath)
    .transform(<span class="keyword">function</span> (content) {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;&gt;</span><span class="delimiter">&quot;</span></span> + content;
    })
    .write(outputFilePath);
<span class="comment">// =&gt; 处理流程类似以下的伪代码</span>
promise.then(<span class="keyword">function</span> <span class="function">read</span>(){
        <span class="keyword">return</span> fs.readFileSync(filePath, <span class="string"><span class="delimiter">&quot;</span><span class="content">utf-8</span><span class="delimiter">&quot;</span></span>);
    }).then(<span class="keyword">function</span> <span class="function">transform</span>(content) {
         <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;&gt;</span><span class="delimiter">&quot;</span></span> + content;
    }).then(<span class="keyword">function</span> <span class="function">write</span>(){
        <span class="keyword">return</span> fs.writeFileSync(filePath, data);
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>看到 <code>promise = promise.then(...)</code> 这种写法，会让人以为<code>promise</code>的值会被覆盖，也许你会想是不是promise的chain被截断了。</p>
</div>
<div class="paragraph">
<p>你可以想象为类似 <code>promise = addPromiseChain(promise, fn);</code> 这样的感觉，我们为promise对象<strong>增加</strong>了新的处理，并返回了这个对象，因此即使自己不实现顺序处理的话也不会带来什么问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="__24">4.7.3. 两者的区别</h4>
<div class="sect4">
<h5 id="__25">同步和异步</h5>
<div class="paragraph">
<p>要说<a href="#fs-method-chain.js">fs-method-chain.js</a>和<a href="#fs-promise-chain.js">Promise版</a>两者之间的差别，最大的不同那就要算是同步和异步了。</p>
</div>
<div class="paragraph">
<p>如果在类似 <a href="#fs-method-chain.js">fs-method-chain.js</a> 的方法链中加入队列等处理的话，就可以实现几乎和异步方法链同样的功能，但是实现将会变得非常复杂，所以我们选择了简单的同步方法链。</p>
</div>
<div class="paragraph">
<p>Promise版的话如同在 <a href="#promise-is-always-async">专栏: Promise只能进行异步处理？</a>里介绍过的一样，只会进行异步操作，因此使用了promise的方法链也是异步的。</p>
</div>
</div>
<div class="sect4">
<h5 id="__26">错误处理</h5>
<div class="paragraph">
<p>虽然<a href="#fs-method-chain.js">fs-method-chain.js</a>里面并不包含错误处理的逻辑，
但是由于是同步操作，因此可以将整段代码用 <code>try-catch</code> 包起来。</p>
</div>
<div class="paragraph">
<p>在 <a href="#fs-promise-chain.js">Promise版</a> 提供了指向内部promise对象的<code>then</code> 和 <code>catch</code> 别名，所以我们可以像其它promise对象一样使用<code>catch</code>来进行错误处理。</p>
</div>
<div class="listingblock">
<div class="title">fs-promise-chain中的错误处理</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> File = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">./fs-promise-chain</span><span class="delimiter">&quot;</span></span>);
File.read(inputFilePath)
    .transform(<span class="keyword">function</span> (content) {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;&gt;</span><span class="delimiter">&quot;</span></span> + content;
    })
    .write(outputFilePath)
    .<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
        console.error(error);
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想在<a href="#fs-method-chain.js">fs-method-chain.js</a>中自己实现异步处理的话，错误处理可能会成为比较大的问题；可以说在进行异步处理的时候，还是使用Promise实现起来比较简单。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_promise_3">4.7.4. Promise之外的异步处理</h4>
<div class="paragraph">
<p>如果你很熟悉Node.js的話，那么看到方法链的话，你是不是会想起来 <a href="http://nodejs.org/api/stream.html">Stream</a> 呢。</p>
</div>
<div class="paragraph">
<p>如果使用 <a href="http://nodejs.org/api/stream.html">Stream</a> 的话，就可以免去了保存 <code>this.lastValue</code> 的麻烦，还能改善处理大文件时候的性能。
另外，使用Stream的话可能会比使用Promise在处理速度上会快些。</p>
</div>
<div class="listingblock">
<div class="title">使用Stream进行read&#8594;transform&#8594;write</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">readableStream.pipe(transformStream).pipe(writableStream);</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，在异步处理的时候并不是说Promise永远都是最好的选择，要根据自己的目的和实际情况选择合适的实现方式。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
Node.js的Stream是一种基于Event的技术
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>关于Node.js中Stream的详细信息可以参考以下网页。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://jxck.hatenablog.com/entry/20111204/1322966453">利用Node.js Stream API对数据进行流式处理 - Block Rockin’ Codes</a></p>
</li>
<li>
<p><a href="http://www.slideshare.net/shigeki_ohtsu/stream2-kihon">Stream2基础</a></p>
</li>
<li>
<p><a href="http://www.slideshare.net/shigeki_ohtsu/node-v012tng12">关于Node-v0.12新功能</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_promise_wrapper">4.7.5. Promise wrapper</h4>
<div class="paragraph">
<p>再回到 <a href="#fs-method-chain.js">fs-method-chain.js</a> 和 <a href="#fs-promise-chain.js">Promise版</a>，这两种方法相比较内部实现也非常相近，让人觉得是不是同步版本的代码可以直接就当做异步方式来使用呢？</p>
</div>
<div class="paragraph">
<p>由于JavaScript可以向对象动态添加方法，所以从理论上来说应该可以从非Promise版自动生成Promise版的代码。（当然静态定义的实现方式容易处理）</p>
</div>
<div class="paragraph">
<p>尽管 <a href="#es6-promises">ES6 Promises</a> 并没有提供此功能，但是著名的第三方Promise实现类库 <a href="https://github.com/petkaantonov/bluebird/">bluebird</a> 等提供了被称为
<a href="https://github.com/petkaantonov/bluebird/blob/master/API.md#promisification">Promisification</a> 的功能。</p>
</div>
<div class="paragraph">
<p>如果使用类似这样的类库，那么就可以动态给对象增加promise版的方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> fs = Promise.promisifyAll(require(<span class="string"><span class="delimiter">&quot;</span><span class="content">fs</span><span class="delimiter">&quot;</span></span>));

fs.readFileAsync(<span class="string"><span class="delimiter">&quot;</span><span class="content">myfile.js</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">utf8</span><span class="delimiter">&quot;</span></span>).then(<span class="keyword">function</span>(contents){
    console.log(contents);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(e){
    console.error(e.stack);
});</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_array_promise_wrapper">Array的Promise wrapper</h5>
<div class="paragraph">
<p>前面的 <a href="https://github.com/petkaantonov/bluebird/blob/master/API.md#promisification">Promisification</a> 具体都干了些什么光凭想象恐怕不太容易理解，我们可以通过给原生的 <code>Array</code> 增加Promise版的方法为例来进行说明。</p>
</div>
<div class="paragraph">
<p>在JavaScript中原生DOM或String等也提供了很多创建方法链的功能。
<code>Array</code> 中就有诸如 <code>map</code> 和 <code>filter</code> 等方法，这些方法会返回一个数组类型，可以用这些方法方便的组建方法链。</p>
</div>
<div id="array-promise-chain.js" class="listingblock">
<div class="title">array-promise-chain.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
<span class="keyword">function</span> <span class="function">ArrayAsPromise</span>(array) {
    <span class="local-variable">this</span>.array = array;
    <span class="local-variable">this</span>.promise = Promise.resolve();
}
ArrayAsPromise.prototype.<span class="function">then</span> = <span class="keyword">function</span> (onFulfilled, onRejected) {
    <span class="local-variable">this</span>.promise = <span class="local-variable">this</span>.promise.then(onFulfilled, onRejected);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
ArrayAsPromise.prototype[<span class="string"><span class="delimiter">&quot;</span><span class="content">catch</span><span class="delimiter">&quot;</span></span>] = <span class="keyword">function</span> (onRejected) {
    <span class="local-variable">this</span>.promise = <span class="local-variable">this</span>.promise.<span class="keyword">catch</span>(onRejected);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
Object.getOwnPropertyNames(Array.prototype).forEach(<span class="keyword">function</span> (methodName) {
    <span class="comment">// Don't overwrite</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> ArrayAsPromise[methodName] !== <span class="string"><span class="delimiter">&quot;</span><span class="content">undefined</span><span class="delimiter">&quot;</span></span>) {
        <span class="keyword">return</span>;
    }
    <span class="keyword">var</span> arrayMethod = Array.prototype[methodName];
    <span class="keyword">if</span> (<span class="keyword">typeof</span>  arrayMethod !== <span class="string"><span class="delimiter">&quot;</span><span class="content">function</span><span class="delimiter">&quot;</span></span>) {
        <span class="keyword">return</span>;
    }
    ArrayAsPromise.prototype[methodName] = <span class="keyword">function</span> () {
        <span class="keyword">var</span> that = <span class="local-variable">this</span>;
        <span class="keyword">var</span> args = <span class="local-variable">arguments</span>;
        <span class="local-variable">this</span>.promise = <span class="local-variable">this</span>.promise.then(<span class="keyword">function</span> () {
            that.array = Array.prototype[methodName].apply(that.array, args);
            <span class="keyword">return</span> that.array;
        });
        <span class="keyword">return</span> <span class="local-variable">this</span>;
    };
});

module.exports = ArrayAsPromise;
module.exports.<span class="function">array</span> = <span class="keyword">function</span> <span class="function">newArrayAsPromise</span>(array) {
    <span class="keyword">return</span> <span class="keyword">new</span> ArrayAsPromise(array);
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>原生的 Array 和 <code>ArrayAsPromise</code> 在使用时有什么差异呢？我们可以通过对 <a href="#array-promise-chain.js">上面的代码</a> 进行测试来了解它们之间的不同点。</p>
</div>
<div id="array-promise-chain-test.js" class="listingblock">
<div class="title">array-promise-chain-test.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
<span class="keyword">var</span> assert = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">power-assert</span><span class="delimiter">&quot;</span></span>);
<span class="keyword">var</span> ArrayAsPromise = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">../src/promise-chain/array-promise-chain</span><span class="delimiter">&quot;</span></span>);
describe(<span class="string"><span class="delimiter">&quot;</span><span class="content">array-promise-chain</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
    <span class="keyword">function</span> <span class="function">isEven</span>(value) {
        <span class="keyword">return</span> value % <span class="integer">2</span> === <span class="integer">0</span>;
    }

    <span class="keyword">function</span> <span class="reserved">double</span>(value) {
        <span class="keyword">return</span> value * <span class="integer">2</span>;
    }

    beforeEach(<span class="keyword">function</span> () {
        <span class="local-variable">this</span>.array = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>];
    });
    describe(<span class="string"><span class="delimiter">&quot;</span><span class="content">Native array</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
        it(<span class="string"><span class="delimiter">&quot;</span><span class="content">can method chain</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
            <span class="keyword">var</span> result = <span class="local-variable">this</span>.array.filter(isEven).map(<span class="reserved">double</span>);
            assert.deepEqual(result, [<span class="integer">4</span>, <span class="integer">8</span>]);
        });
    });
    describe(<span class="string"><span class="delimiter">&quot;</span><span class="content">ArrayAsPromise</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
        it(<span class="string"><span class="delimiter">&quot;</span><span class="content">can promise chain</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> (done) {
            <span class="keyword">var</span> array = <span class="keyword">new</span> ArrayAsPromise(<span class="local-variable">this</span>.array);
            array.filter(isEven).map(<span class="reserved">double</span>).then(<span class="keyword">function</span> (value) {
                assert.deepEqual(value, [<span class="integer">4</span>, <span class="integer">8</span>]);
            }).then(done, done);
        });
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们看到，在 <code>ArrayAsPromise</code> 中也能使用 Array的方法。而且也和前面的例子类似，原生的Array是同步处理，而 <code>ArrayAsPromise</code> 则是异步处理，这也是它们的不同之处。</p>
</div>
<div class="paragraph">
<p>仔细看一下 <code>ArrayAsPromise</code> 的实现，也许你已经注意到了， <code>Array.prototype</code> 的所有方法都被实现了。
但是，<code>Array.prototype</code> 中也存在着类似<code>array.indexOf</code> 等并不会返回数组类型数据的方法，这些方法如果也要支持方法链的话就有些不自然了。</p>
</div>
<div class="paragraph">
<p>在这里非常重要的一点是，我们可以通过这种方式，为具有接收相同类型数据接口的API动态的创建Promise版的API。
如果我们能意识到这种API的规则性的话，那么就可能发现一些新的使用方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>前面我们看到的 <a href="https://github.com/petkaantonov/bluebird/blob/master/API.md#promisification">Promisification</a> 方法，借鉴了了 Node.js的Core模块中在进行异步处理时将 <code>function(error,result){}</code> 方法的第一个参数设为 <code>error</code> 这一规则，自动的创建由Promise包装好的方法。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__27">4.7.6. 总结</h4>
<div class="paragraph">
<p>在本小节我们主要学习了下面的这些内容。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Promise版的方法链实现</p>
</li>
<li>
<p>Promise并不是总是异步编程的最佳选择</p>
</li>
<li>
<p>Promisification</p>
</li>
<li>
<p>统一接口的重用</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#es6-promises">ES6 Promises</a>只提供了一些Core级别的功能。
因此，我们也许需要对现有的方法用Promise方式重新包装一下。</p>
</div>
<div class="paragraph">
<p>但是，类似Event等调用次数没有限制的回调函数等在并不适合使用Promise，Promise也不能说什么时候都是最好的选择。</p>
</div>
<div class="paragraph">
<p>至于什么情况下应该使用Promise，什么时候不该使用Promise，并不是本书要讨论的目的，
我们需要牢记的是不要什么都用Promise去实现，我想最好根据自己的具体目的和情况，来考虑是应该使用Promise还是其它方法。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="promise-sequence">4.8. 使用Promise进行顺序（sequence）处理</h3>
<div class="paragraph">
<p>在第2章 <a href="#ch2-promise-all">Promise.all</a> 中，我们已经学习了如何让多个promise对象同时开始执行的方法。</p>
</div>
<div class="paragraph">
<p>但是 <code>Promise.all</code> 方法会同时运行多个promise对象，如果想进行在A处理完成之后再开始B的处理，对于这种顺序执行的话 <code>Promise.all</code>就无能为力了。</p>
</div>
<div class="paragraph">
<p>此外，在同一章的<a href="#ch2-promise-and-array">Promise和数组</a> 中，我们也介绍了一种效率不是特别高的，使用了 <a href="#multiple-xhr.js">重复使用多个then的方法</a> 来实现如何按顺序进行处理。</p>
</div>
<div class="paragraph">
<p>在本小节中，我们将对如何在Promise中进行顺序处理进行介绍。</p>
</div>
<div class="sect3">
<h4 id="__28">4.8.1. 循环和顺序处理</h4>
<div class="paragraph">
<p>在 <a href="#multiple-xhr.js">重复使用多个then的方法</a> 中的实现方法如下。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">getURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onload</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.status === <span class="integer">200</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
<span class="keyword">var</span> request = {
        <span class="function">comment</span>: <span class="keyword">function</span> <span class="function">getComment</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        },
        <span class="function">people</span>: <span class="keyword">function</span> <span class="function">getPeople</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/people.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        }
    };
<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="keyword">function</span> <span class="function">recordValue</span>(results, value) {
        results.push(value);
        <span class="keyword">return</span> results;
    }
    <span class="comment">// [] 用来保存初始化的值</span>
    <span class="keyword">var</span> pushValue = recordValue.bind(<span class="predefined-constant">null</span>, []);
    <span class="keyword">return</span> request.comment().then(pushValue).then(request.people).then(pushValue);
}
<span class="comment">// 运行示例</span>
main().then(<span class="keyword">function</span> (value) {
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用这种写法的话那么随着 <code>request</code> 中元素数量的增加，我们也需要不断增加对 <code>then</code> 方法的调用</p>
</div>
<div class="paragraph">
<p>因此，如果我们将处理内容统一放到数组里，再配合for循环进行处理的话，那么处理内容的增加将不会再带来什么问题。首先我们就使用for循环来完成和前面同样的处理。</p>
</div>
<div id="promise-foreach-xhr.js" class="listingblock executable">
<div class="title">promise-foreach-xhr.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">getURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onload</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.status === <span class="integer">200</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
<span class="keyword">var</span> request = {
        <span class="function">comment</span>: <span class="keyword">function</span> <span class="function">getComment</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        },
        <span class="function">people</span>: <span class="keyword">function</span> <span class="function">getPeople</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/people.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        }
    };
<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="keyword">function</span> <span class="function">recordValue</span>(results, value) {
        results.push(value);
        <span class="keyword">return</span> results;
    }
    <span class="comment">// [] 用来保存初始化值</span>
    <span class="keyword">var</span> pushValue = recordValue.bind(<span class="predefined-constant">null</span>, []);
    <span class="comment">// 返回promise对象的函数的数组</span>
    <span class="keyword">var</span> tasks = [request.comment, request.people];
    <span class="keyword">var</span> promise = Promise.resolve();
    <span class="comment">// 开始的地方</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="integer">0</span>; i &lt; tasks.length; i++) {
        <span class="keyword">var</span> task = tasks[i];
        promise = promise.then(task).then(pushValue);
    }
    <span class="keyword">return</span> promise;
}
<span class="comment">// 运行示例</span>
main().then(<span class="keyword">function</span> (value) {
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用for循环的时候，如同我们在 <a href="#then-return-new-promise">专栏: 每次调用then都会返回一个新创建的promise对象</a> 以及 <a href="#promise-and-method-chain">Promise和方法链</a> 中学到的那样，每次调用 <a href="#promise.then">Promise#then</a> 方法都会返回一个新的promise对象。</p>
</div>
<div class="paragraph">
<p>因此类似 <code>promise = promise.then(task).then(pushValue);</code> 的代码就是通过不断对promise进行处理，不断的覆盖 <code>promise</code> 变量的值，以达到对promise对象的累积处理效果。</p>
</div>
<div class="paragraph">
<p>但是这种方法需要 <code>promise</code> 这个临时变量，从代码质量上来说显得不那么简洁。</p>
</div>
<div class="paragraph">
<p>如果将这种循环写法改用 <code>Array.prototype.reduce</code> 的话，那么代码就会变得聪明多了。</p>
</div>
</div>
<div class="sect3">
<h4 id="_promise_chain_reduce">4.8.2. Promise chain和reduce</h4>
<div class="paragraph">
<p>如果将上面的代码用 <code>Array.prototype.reduce</code> 重写的话，会像下面一样。</p>
</div>
<div id="promise-reduce-xhr.js" class="listingblock executable">
<div class="title">promise-reduce-xhr.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">getURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onload</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.status === <span class="integer">200</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
<span class="keyword">var</span> request = {
        <span class="function">comment</span>: <span class="keyword">function</span> <span class="function">getComment</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        },
        <span class="function">people</span>: <span class="keyword">function</span> <span class="function">getPeople</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/people.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        }
    };
<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="keyword">function</span> <span class="function">recordValue</span>(results, value) {
        results.push(value);
        <span class="keyword">return</span> results;
    }
    <span class="keyword">var</span> pushValue = recordValue.bind(<span class="predefined-constant">null</span>, []);
    <span class="keyword">var</span> tasks = [request.comment, request.people];
    <span class="keyword">return</span> tasks.reduce(<span class="keyword">function</span> (promise, task) {
        <span class="keyword">return</span> promise.then(task).then(pushValue);
    }, Promise.resolve());
}
<span class="comment">// 运行示例</span>
main().then(<span class="keyword">function</span> (value) {
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码中除了 <code>main</code> 函数之外的其他处理都和使用for循环的时候相同。</p>
</div>
<div class="paragraph">
<p><code>Array.prototype.reduce</code> 的第二个参数用来设置盛放计算结果的初始值。在这个例子中， <code>Promise.resolve()</code> 会赋值给 <code>promise</code> ，此时的 <code>task</code> 为 <code>request.comment</code> 。</p>
</div>
<div class="paragraph">
<p>在reduce中第一个参数中被 <code>return</code> 的值，则会被赋值为下次循环时的 <code>promise</code> 。也就是说，通过返回由 <code>then</code> 创建的新的promise对象，就实现了和for循环类似的 <a href="#promise-chain">Promise chain</a> 了。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>下面是关于 <code>Array.prototype.reduce</code> 的详细说明。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">Array.prototype.reduce() - JavaScript | MDN</a></p>
</li>
<li>
<p><a href="http://glide.so/azu/6919649">azu / Array.prototype.reduce Dance - Glide</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>使用reduce和for循环不同的地方是reduce不再需要临时变量 <code>promise</code> 了，因此也不用编写 <code>promise = promise.then(task).then(pushValue);</code> 这样冗长的代码了，这是非常大的进步。</p>
</div>
<div class="paragraph">
<p>虽然 <code>Array.prototype.reduce</code> 非常适合用来在Promise中进行顺序处理，但是上面的代码有可能让人难以理解它是如何工作的。</p>
</div>
<div class="paragraph">
<p>因此我们再来编写一个名为 <code>sequenceTasks</code> 的函数，它接收一个数组作为参数，数组里面存放的是要进行的处理Task。</p>
</div>
<div class="paragraph">
<p>从下面的调用代码中我们可以非常容易的从其函数名想到，该函数的功能是对 <code>tasks</code> 中的处理进行顺序执行了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> tasks = [request.comment, request.people];
sequenceTasks(tasks);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__29">4.8.3. 定义进行顺序处理的函数</h4>
<div class="paragraph">
<p>基本上我们只需要基于 <a href="#promise-reduce-xhr.js">使用reduce的方法</a> 重构出一个函数。</p>
</div>
<div id="promise-sequence.js" class="listingblock">
<div class="title">promise-sequence.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">sequenceTasks</span>(tasks) {
    <span class="keyword">function</span> <span class="function">recordValue</span>(results, value) {
        results.push(value);
        <span class="keyword">return</span> results;
    }
    <span class="keyword">var</span> pushValue = recordValue.bind(<span class="predefined-constant">null</span>, []);
    <span class="keyword">return</span> tasks.reduce(<span class="keyword">function</span> (promise, task) {
        <span class="keyword">return</span> promise.then(task).then(pushValue);
    }, Promise.resolve());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>需要注意的一点是，和 <code>Promise.all</code> 等不同，这个函数接收的参数是一个函数的数组。</p>
</div>
<div class="paragraph">
<p>为什么传给这个函数的不是一个promise对象的数组呢？这是因为promise对象创建的时候，XHR已经开始执行了，因此再对这些promise对象进行顺序处理的话就不能正常工作了。</p>
</div>
<div class="paragraph">
<p>因此 <code>sequenceTasks</code> 将函数(该函数返回一个promise对象)的数组作为参数。</p>
</div>
<div class="paragraph">
<p>最后，使用 <code>sequenceTasks</code> 重写最开始的例子的话，如下所示。</p>
</div>
<div id="promise-sequence-xhr.js" class="listingblock executable">
<div class="title">promise-sequence-xhr.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">sequenceTasks</span>(tasks) {
    <span class="keyword">function</span> <span class="function">recordValue</span>(results, value) {
        results.push(value);
        <span class="keyword">return</span> results;
    }
    <span class="keyword">var</span> pushValue = recordValue.bind(<span class="predefined-constant">null</span>, []);
    <span class="keyword">return</span> tasks.reduce(<span class="keyword">function</span> (promise, task) {
        <span class="keyword">return</span> promise.then(task).then(pushValue);
    }, Promise.resolve());
}
<span class="keyword">function</span> <span class="function">getURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onload</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.status === <span class="integer">200</span>) {
                resolve(req.responseText);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
<span class="keyword">var</span> request = {
        <span class="function">comment</span>: <span class="keyword">function</span> <span class="function">getComment</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        },
        <span class="function">people</span>: <span class="keyword">function</span> <span class="function">getPeople</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/people.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        }
    };
<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="keyword">return</span> sequenceTasks([request.comment, request.people]);
}
<span class="comment">// 运行示例</span>
main().then(<span class="keyword">function</span> (value) {
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>怎样， <code>main()</code> 中的流程是不是更清晰易懂了。</p>
</div>
<div class="paragraph">
<p>如上所述，在Promise中，我们可以选择多种方法来实现处理的按顺序执行。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#multiple-xhr.js">循环使用then调用的方法</a></p>
</li>
<li>
<p><a href="#promise-foreach-xhr.js">使用for循环的方法</a></p>
</li>
<li>
<p><a href="#promise-reduce-xhr.js">使用reduce的方法</a></p>
</li>
<li>
<p><a href="#promise-sequence.js">分离出顺序处理函数的方法</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但是，这些方法都是基于JavaScript中对数组及进行操作的for循环或 <code>forEach</code> 等，本质上并无大区别。
因此从一定程度上来说，在处理Promise的时候，将大块的处理分成小函数来实现是一个非常好的实践。</p>
</div>
</div>
<div class="sect3">
<h4 id="__30">4.8.4. 总结</h4>
<div class="paragraph">
<p>在本小节中，我们对如何在Promise中进行和 <a href="#Promise.all"><code>Promise.all</code></a> 相反，按顺序让promise一个个进行处理的实现方式进行了介绍。</p>
</div>
<div class="paragraph">
<p>为了实现顺序处理，我们也对从过程风格的编码方式到自定义顺序处理函数的方式等实现方式进行了介绍，也再次强调了在Promise领域我们应遵循将处理按照函数进行划分的基本原则。</p>
</div>
<div class="paragraph">
<p>在Promise中如果还使用了Promise chain将多个处理连接起来的话，那么还可能使源代码中的一条语句变得很长。</p>
</div>
<div class="paragraph">
<p>这时候如果我们回想一下这些编程的基本原则进行函数拆分的话，代码整体结构会变得非常清晰。</p>
</div>
<div class="paragraph">
<p>此外,Promise的构造函数以及 <code>then</code> 都是高阶函数，如果将处理分割为函数的话，还能得到对函数进行灵活组合使用的副作用，意识到这一点对我们也会有一些帮助的。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
高阶函数指的是一个函数可以接受其参数为函数对象的实例
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="promise-api-reference">5. Promises API Reference</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="promise.then">5.1. Promise#then</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">promise.then(onFulfilled, onRejected);</code></pre>
</div>
</div>
<div class="listingblock executable">
<div class="title">then代码示例</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve, reject){
    resolve(<span class="string"><span class="delimiter">&quot;</span><span class="content">传递给then的值</span><span class="delimiter">&quot;</span></span>);
});
promise.then(<span class="keyword">function</span> (value) {
    console.log(value);
}, <span class="keyword">function</span> (error) {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码创建一个promise对象，定义了处理onFulfilled和onRejected的函数（handler），然后返回这个promise对象。</p>
</div>
<div class="paragraph">
<p>这个promise对象会在变为resolve或者reject的时候分别调用相应注册的回调函数。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当handler返回一个正常值的时候，这个值会传递给promise对象的onFulfilled方法。</p>
</li>
<li>
<p>定义的handler中产生异常的时候，这个值则会传递给promise对象的onRejected方法。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="promise.catch">5.2. Promise#catch</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">promise.<span class="keyword">catch</span>(onRejected);</code></pre>
</div>
</div>
<div class="listingblock executable">
<div class="title">catch代码示例</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve, reject){
    resolve(<span class="string"><span class="delimiter">&quot;</span><span class="content">传递给then的值</span><span class="delimiter">&quot;</span></span>);
});
promise.then(<span class="keyword">function</span> (value) {
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个等价于<code>promise.then(undefined, onRejected)</code> 的语法糖。</p>
</div>
</div>
<div class="sect2">
<h3 id="Promise.resolve">5.3. Promise.resolve</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Promise.resolve(promise);
Promise.resolve(thenable);
Promise.resolve(object);</code></pre>
</div>
</div>
<div class="listingblock executable">
<div class="title">Promise.resolve代码示例</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> taskName = <span class="string"><span class="delimiter">&quot;</span><span class="content">task 1</span><span class="delimiter">&quot;</span></span>
asyncTask(taskName).then(<span class="keyword">function</span> (value) {
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    console.error(error);
});
<span class="keyword">function</span> <span class="function">asyncTask</span>(name){
    <span class="keyword">return</span> Promise.resolve(name).then(<span class="keyword">function</span>(value){
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Done! </span><span class="delimiter">&quot;</span></span>+ value;
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据接收到的参数不同，返回不同的promise对象。</p>
</div>
<div class="paragraph">
<p>虽然每种情况都会返回promise对象，但是大体来说主要分为下面3类。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">接收到promise对象参数的时候</dt>
<dd>
<p>返回的还是接收到的promise对象</p>
</dd>
<dt class="hdlist1">接收到thenable类型的对象的时候</dt>
<dd>
<p>返回一个新的promise对象，这个对象具有一个 <code>then</code> 方法</p>
</dd>
<dt class="hdlist1">接收的参数为其他类型的时候（包括JavaScript对或null等）</dt>
<dd>
<p>返回一个将该对象作为值的新promise对象</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="Promise.reject">5.4. Promise.reject</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Promise.reject(object)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Promise.reject代码示例</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> failureStub = sinon.stub(xhr, <span class="string"><span class="delimiter">&quot;</span><span class="content">request</span><span class="delimiter">&quot;</span></span>).returns(Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">bad!</span><span class="delimiter">&quot;</span></span>)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回一个使用接收到的值进行了reject的新的promise对象。</p>
</div>
<div class="paragraph">
<p>而传给Promise.reject的值也应该是一个 <code>Error</code> 类型的对象。</p>
</div>
<div class="paragraph">
<p>另外，和 Promise.resolve不同的是，即使Promise.reject接收到的参数是一个promise对象，该函数也还是会返回一个全新的promise对象。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> r = Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">error</span><span class="delimiter">&quot;</span></span>));
console.log(r === Promise.reject(r));<span class="comment">// false</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Promise.all">5.5. Promise.all</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Promise.all(promiseArray);</code></pre>
</div>
</div>
<div class="listingblock executable">
<div class="title">Promise.all代码示例</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> p1 = Promise.resolve(<span class="integer">1</span>),
    p2 = Promise.resolve(<span class="integer">2</span>),
    p3 = Promise.resolve(<span class="integer">3</span>);
Promise.all([p1, p2, p3]).then(<span class="keyword">function</span> (results) {
    console.log(results);  <span class="comment">// [1, 2, 3]</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>生成并返回一个新的promise对象。</p>
</div>
<div class="paragraph">
<p>参数传递promise数组中所有的promise对象都变为resolve的时候，该方法才会返回，
新创建的promise则会使用这些promise的值。</p>
</div>
<div class="paragraph">
<p>如果参数中的任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的promise对象。</p>
</div>
<div class="paragraph">
<p>由于参数数组中的每个元素都是由 <code>Promise.resolve</code> 包装（wrap）的，所以Paomise.all可以处理不同类型的promose对象。</p>
</div>
</div>
<div class="sect2">
<h3 id="Promise.race">5.6. Promise.race</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Promise.race(promiseArray);</code></pre>
</div>
</div>
<div class="listingblock executable">
<div class="title">Promise.race代码示例</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> p1 = Promise.resolve(<span class="integer">1</span>),
    p2 = Promise.resolve(<span class="integer">2</span>),
    p3 = Promise.resolve(<span class="integer">3</span>);
Promise.race([p1, p2, p3]).then(<span class="keyword">function</span> (value) {
    console.log(value);  <span class="comment">// 1</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>生成并返回一个新的promise对象。</p>
</div>
<div class="paragraph">
<p>参数 promise 数组中的任何一个promise对象如果变为resolve或者reject的话，
该函数就会返回，并使用这个promise对象的值进行resolve或者reject。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="promise-glossary">6. 用語集</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">Promises</dt>
<dd>
<p>Promise规范自身</p>
</dd>
<dt class="hdlist1">promise对象</dt>
<dd>
<p>promise对象指的是 <code>Promise</code> 实例对象</p>
</dd>
</dl>
</div>
<div id="es6-promises" class="dlist">
<dl>
<dt class="hdlist1">ES6 Promises</dt>
<dd>
<p>如果想明确表示使用 <a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects">ECMAScript 6th Edition</a> 的话，可以使用<em>ES6</em>作为前缀（prefix）</p>
</dd>
</dl>
</div>
<div id="promises-aplus" class="dlist">
<dl>
<dt class="hdlist1">Promises/A+</dt>
<dd>
<p><a href="http://promises-aplus.github.io/promises-spec/">Promises/A+</a>。
这是ES6 Promises的前身，是一个社区规范，它和 ES6 Promises 有很多共通的内容。</p>
</dd>
</dl>
</div>
<div id="Thenable" class="dlist">
<dl>
<dt class="hdlist1">Thenable</dt>
<dd>
<p>类Promise对象。
拥有名为<code>.then</code>方法的对象。</p>
</dd>
</dl>
</div>
<div id="promise-chain" class="dlist">
<dl>
<dt class="hdlist1">promise chain</dt>
<dd>
<p>指使用 <code>then</code> 或者 <code>catch</code> 方法将promise对象连接起来的行为。
此用语只是在本书中的说法，而不是在 <a href="#es6-promises">ES6 Promises</a> 中定义的官方用语。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="resouce-link">7. 参考网站</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://github.com/w3ctag/promises-guide">w3ctag/promises-guide</a></dt>
<dd>
<p>Promises指南 - 这里有很多关于概念方面的说明</p>
</dd>
<dt class="hdlist1"><a href="https://github.com/domenic/promises-unwrapping">domenic/promises-unwrapping</a></dt>
<dd>
<p>ES6 Promises规范的repo - 可以通过查看issue来了解各种关于规范的来龙去脉和信息</p>
</dd>
<dt class="hdlist1"><a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects">ECMAScript Language Specification ECMA-262 6th Edition – DRAFT</a></dt>
<dd>
<p>ES6 Promises的规范 - 如果想参考关于ES6 Promises的规范，则应该先看这里</p>
</dd>
<dt class="hdlist1"><a href="http://www.html5rocks.com/en/tutorials/es6/promises/?redirect_from_locale=ja">JavaScript Promises: There and back again - HTML5 Rocks</a></dt>
<dd>
<p>关于Promises的文章 - 这里的示例代码和参考（reference）的完成度都很高</p>
</dd>
<dt class="hdlist1"><a href="http://d.hatena.ne.jp/jovi0608/20140319/1395199285">Node.js Promise再次降临！ - ぼちぼち日記</a></dt>
<dd>
<p>关于Node.js和Promise的文章 - <em>thenable</em>部分参考了本文</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="about-author">8. 关于作者</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="image"><img src="Appendix-Glossary/img/simple320_320.png" alt="azu" width="32" height="32"></span>
<strong><a href="https://github.com/azu/">azu</a></strong> (Twitter : @<a href="https://twitter.com/azu_re">azu_re</a> )</p>
</div>
<div class="paragraph">
<p>关注浏览器、JavaScript先关的最新技术。</p>
</div>
<div class="paragraph">
<p>擅长将将目的作为手段，本书也是因此而成。</p>
</div>
<div class="paragraph">
<p>管理着个人主页 <a href="http://efcl.info/">Web Scratch</a> 和 <a href="http://jser.info/">JSer.info</a> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="about-translators">9. 关于译者</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>liubin <a href="https://github.com/liubin">https://github.com/liubin</a></p>
<div class="ulist">
<ul>
<li>
<p>除去kakau和honnkyou的其余部分的翻译、整体校对，以及源代码，工具部分的翻译</p>
</li>
</ul>
</div>
</li>
<li>
<p>kaku <a href="https://github.com/kaku87">https://github.com/kaku87</a></p>
<div class="ulist">
<ul>
<li>
<p>1.1. Promise是什么、1.2. Promise 简介、1.3. 编写Promise代码</p>
</li>
</ul>
</div>
</li>
<li>
<p>honnkyou <a href="https://github.com/honnkyou">https://github.com/honnkyou</a></p>
<div class="ulist">
<ul>
<li>
<p>3.1. 基本测试</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="omake-message">9.1. 给原著者留言、后记</h3>
<div class="paragraph">
<p><a href="https://gumroad.com/l/javascript-promise">后记.pdf</a> 里面记录了笔者为什么要写这么一本书，编写的过程，以及如何进行测试。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="image"><a class="image" href="https://gumroad.com/l/javascript-promise"><img src="public/img/gumroad-green.svg" alt="下载后记（日文版）"></a></span> <a href="https://gumroad.com/l/javascript-promise">JavaScript Promise迷你书后记（日文版）</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你可以在Gumroad以免费的价格或者自己设定一个任意的价格来下载本书的后记。</p>
</div>
<div class="paragraph">
<p>在下载的时候，会有一个给作者留言的地方，
希望各位读者能写下一点什么之后下载。</p>
</div>
<div class="paragraph">
<p>如果本书有任何问题的话，也可以通过 GitHub或者Gitter 来提交。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/azu/promises-book/issues?state=open">Issues · azu/promises-book</a></p>
</li>
<li>
<p><a href="https://gitter.im/azu/promises-book">azu/promises-book - Gitter</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.4.1<br>
Last updated 2015-02-03 22:18:13 CST
</div>
</div>
</body>
</html>
